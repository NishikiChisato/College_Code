# TCP/IP 网络模型有哪几层



由于设备的类型是多种多样的，因此在不同的设备间进行通信需要协商出一套**通用的网络协议**。

该网络协议是分层的，对于 TCP/IP 协议而言，从上到下分为：应用层、传输层、网络层、网络接口层。

这些分层都是理论模型，并不涉及具体的硬件实现



## 应用层

应用层为最上层，我们所使用的软件都是在应用层实现的。

当两台设备需要传输数据时，应用层只需要把数据传输给下一层，也就是传输层。并且应用层不会去关心数据时如何传输的。

应用层工作在操作系统的用户态，传输层及以下的则工作在核心态



## 传输层

应用层的数据包会传输给传输层，传输层为应用提供网络支持。

传输层有两个传输协议：**TCP 和 UDP**。

大多数应用使用的传输协议是 TCP。TCP 比 UDP 多了很多特性，这些特性能够保证数据能够可靠地传输给对方。

UDP 则没有那么多屁事。它只负责发送数据，不保证数据包能否抵达对方，但它的实时性也相对更好，传输效率也高。

TCP 会在原本数据的基础上**加上 TCP 头部**组成 TCP 报文，然后再将 TCP 报文传输给**网络层**

应用需要传输的数据可能非常大，如果直接传输会出现很多问题。因此当数据包大小超过 MSS（TCP 最大报文长度）时，就要对其分块。这样如果有某一个分块损坏只需要重传这个分块即可。在TCP 协议中，每个分块称为一个 **TCP 段**。

上面都是应用作为发送方的情况。当设备作为接受方时，传输层需要将数据传输给应用。但一台设备上可能会有很多应用在接受数据，这时就需要一个编号来将应用区分开，这个编号就是**端口。**

比如 80 端口通常是给服务器使用的，22 端口是远程登录服务器使用的。由于浏览器（客户端）当中的每一个标签页都是一个独立的进程，操作系统会为这些进程分配临时的端口号。

传输层当中的报文都会携带端口号，因此接收方可以辨别出这个报文是发给谁的。



## 网络层

传输层的任务是服务于应用，负责应用与应用之间的传输，而实际的传输则要靠网络层。

网络层所使用的是 **IP 协议**。IP 协议会将**传输层**的报文作为**数据部分**，在前面加上 IP 头部组成 IP 报文。

如果 IP 报文的大小超过 MTU 就会再次进行分片，最终得到一个准备发送到网络当中的 IP 报文

![图1](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/12.jpg)

网络层负责将数据从一个设备传输到另一个设备。那么这里就必须要有一个编号来对设备进行区分，这个编号就是我们通常说的 **IP 地址**。

**端口号是对接受数据的应用进行区分，IP 地址是对设备进行区分**，显然后者的范围更大

我们会用 IP 地址给设备编号。对于 IPv4 协议，IP 地址有 32 位，它们被分成四段（如：192.168.100.1），每段 8 位，每段的最大数是 255。

但是如果只有一个 IP 地址来对设备进行区分，那么寻址起来会非常麻烦。因为全世界会有非常多的设备，我们不能一个一个去匹配。

因此，我们将 IP 地址划分为了两种意义

* 一个是**网络号**，用来表示该 IP 地址属于哪个 「子网」
* 一个是**主机号**，用来表示同一「子网」下的不同主机

这里面具体的划分就需要引入**子网掩码**的概念了。

举个例子，假设 IP 地址为 10.100.122.0/24 ，这后面的 /24 表示 255.255.255.0（相当于 32 位当中有 24 个 1，为了简化就写成了 /24 ）。

那么我们要具体如何计算呢：很简单，只需要将 IP 地址与子网掩码进行**按位与**的操作就可以得到**网络号**

![图2](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/16.jpg)

按位与是「两个都是 1 结果才是1，只要有一个是 0 那么结果就是 0 」

最终的网络号是 32 位的。

将 IP 地址与**子网掩码取反后的结果**进行**按位与**运算，就可以得到**主机号。**

在寻址过程中，会先匹配网络号（先找子网），才会去找主机号。

IP 协议除了用于寻址外，还有一个重要能力是**路由**。在实际的场景中，两台设备之间并不是直接通过一根网线连接的，这中间会有很多网关、路由器、交换机等设备。每当网络包到达一个节点（设备）时，都需要通过路由算法来决定接下来往哪里走。

路由器的工作是将这个网络包转发到对应的子网内，它只需要知道网络号就可以了。

![图3](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/17.jpg)



## 网络接口层

在生成了 IP 头部之后，接下来要交给**网络接口层**，它会在 IP 头部的前面加上 MAC 头部，在结尾加上校验码，将这个整体封装成**数据帧**发送到以太网上。

以太网在判断网络包的目的地的方式不同于 IP ，因此需要相应的方式才能在以太网中将数据包传输到正确的地方，而 MAC 头部就是干这个的。因此，**在以太网中寻址主要靠 MAC 地址**。

MAC 头部当中包含了**发送方**和**接收方**的 MAC 地址，我们可以通过 ARP 协议来获取对方的 MAC 地址。

网络接口层主要是为网络层提供「物理上」的传输服务，负责在以太网、WIFI 等底层网络上发送数据包，通过 MAC 地址来标识设备。

## 总结

具体的封装如下图：

![图4](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E5%B0%81%E8%A3%85.png)



HTTP 的传输单位是消息或报文（ message ）、TCP 层的传输单位是段（ segment ）、IP 层的传输单位是包（ packet ），网络接口层的传输单位是帧（ frame ）



# 键入网址到网页显示，期间发生了什么



总体流程如下：

![图5](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/2.jpg)



## HTTP

* 浏览器做的第一步是解析 URL（网址）

浏览器会先对 URL 进行解析，从而生成发送给 web 服务器的请求信息。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/3.jpg)



URL 的前面一部分是服务器名称，后面一部分是服务器某一目录下的文件资源，即浏览器请求的文件资源。

如果没有路径名，那么会默认访问事先设置的**默认文件**，也就是 `/index.hrml` 或者 `/default.html` ，这样就不会发生混乱。



* 生成 HTTP 请求消息

对 URL 进行解析之后，浏览器就知道了 **Web 服务器和文件名** ，接下来就是根据这俩生成 HTTP 请求消息了。

HTTP 阶段的数据包称为消息或报文。既然有请求报文自然也有响应报文，如下：

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/4.jpg)



## DNS 寻址

浏览器解析完 URL 并生成 HTTP 报文后，需要委托操作系统将报文发送给 Web 服务器。然后你就会发现：我只知道这个服务器的名称，我不知道它的 IP 地址啊。

浏览器不可能将所有服务器的 IP 地址全部保存，最多会有个几分钟的缓存。也就是说我们要去查询服务器的 IP 地址。

为解决这个问题，专门有一种服务器保存了 Web 服务器域名与 IP 之间的对应关系，这就是 DNS 服务器。

* 域名之间的层级关系

服务器的域名都是用句点来进行分割的，比如 `www.serve.com` ，句点表示不同的层级，**越靠右层级越高**。

实际上域名的最后还有一个点，即完整域名为 `www.serve.com.` ，最后那个点代表根域名。

也就是说，`.` 表示根域，下一层是顶级域 `.com` ，再下面是 `serve.com` 。

它们之间的关系为：

* 根 DNS 服务器 `.`
* 顶级域 DNS 服务器 `.com`

* 权威 DNS 服务器 `serve.com`

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/5.jpg)



**根域的 DNS 服务器信息会保存在互联网中所有的 DNS 服务器中**。

因此，只需要找到一台服务器，就可以找到并访问根域服务器。然后再从根域服务器逐步向下寻找，最终就可以找到目标服务器的 IP 地址。

* DNS 请求流程

1. 客户端首先会发出一个 DNS 请求给本地的 DNS 服务器（就是客户端的 TCP/IP 设置中填写的 DNS 服务器地址），问 `www.serve.com` 的 IP 地址是啥。
2. 本地 DNS 服务器收到客户端的请求后，如果缓存当中能找到该域名对应的 IP ，那么将直接返回。如果没有，那么它会向根域名服务器发出请求
3. 根 DNS 服务器收到本地 DNS 服务器的请求后，发现该域名后缀是 `.com` ，于是返回 `.com` 的 IP 地址，让本地 DNS 服务器去 `.com` 服务器那里查找
4. 收到地址后，本地 DNS 服务器向 `.com` 服务器发出请求，`.com` 则向本地服务器返回 `www.serve.com` 的服务器 IP 地址
5. 接着，`www.serve.com` 域名下的 DNS 服务器会返回本地 DNS 服务器所请求的域名所对应的 IP 地址
6. 最后，本地服务器将该 IP 地址返回给客户端

具体的如下图

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/6.jpg)



当然，并不是说每一次输入网址都会进行这么多的步骤，是的话还要缓存干什么。

浏览器会先看看自己有没有这个域名对应的 IP 地址的缓存，有的话就直接返回。没有的话会去问操作系统，操作系统会看一看自己的缓存。如果还没有，再去 hosts 文件看，这还没有，才会去问本地 DNS 服务器。



## 协议栈



应用程序通过 DNS 服务器获取到域名的 IP 地址后，会将 HTTP 的报文**传输**工作交由操作系统当中的**协议栈**执行。

协议栈由上下两部分组成，上面会向下面的部分委托工作，下面的部分则会实际进行执行。即上面接受任务，下面执行任务。

当然，应用程序（浏览器）并不能直接委托协议栈进行工作，这有悖于操作系统的规则。因此应用程序需要通过一个工具来委托协议栈来对 HTTP 报文进行传输，这个工具就是 **Socket 库**。

协议栈的上半部分接收数据的协议有 TCP 和 UDP 两种。协议栈的下面部分是通过 IP 协议来控制网络包的**实际收发的**。

也就是说， HTTP 报文会先经过 TCP 部分，加上了 TCP 头部之后会委托给 IP 部分，再加上 IP 头部后会执行实际的收发操作。

此外，IP 中还包括 ICMP 协议和 ARP 协议。

* ICMP 协议用于告知网络包传输过程中产生的错误以及各种控制信息
* ARP 协议用于根据 IP 来查询响应的 MAC 地址



## TCP

### TCP 头部组成

当网络包进过 TCP 模块时，会在其前面加上 TCP 头部，其格式如下：

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/8.jpg)



这里的**源端口号**和**目标端口号**指的是报文发出的应用以及接收的应用。**包的序号**是为了解决包乱序的问题。

当然，TCP 会检查对方是否收到，因此会有**确认号**。如果对方没有收到，则需要重新发送。

TCP 还有一些状态位来检验双方目前所处在的状态。

* `SYN` 是发起一个连接
* `ACK` 是回复
* `RST` 是重新连接
* `FIN` 是结束连接

TCP 是面向连接的，包当中的这些状态位的标志说明了**连接双方目前所处在的状态**。

还有一个是**窗口大小**。这是因为 TCP 要做**流量控制**，通信的双方各有一个窗口（缓存），该窗口的大小即为处理数据的能力大小。

除了流量控制以外，TCP 还会做**拥塞控制**。这里实际上指的是包的发送速度。你发的太快，对面撑死，发的太慢，对面饿死。



### 三次握手



* TCP 在传输数据之前，会先进行三次握手来建立连接

连接，实际上是一个状态。**每当 TCP 头部当中的状态位发生变化时，双方的状态就会发生变化**，具体的情况如下：

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png)



* 一开始，客户端与服务端都处于 `CLOSE` 状态，但是服务端会**主动**监听某个端口，即服务端会处于 `LISTEN` 状态。 
* 往后，客户端会发起连接 `SYN` ，即**发送一个 `SYN` 序列号（这个序列号是由客户端自己算出来的）**。此后客户端处于 `SYN-SENT` 状态。
  * 对应蓝色箭头
* 服务端收到后会**返回一个 `SYN` 号和 `ACK` 号**。**前者为服务端自己生成的**，**后者为在客户端发送过来的 `SYN` 号的基础上加上 1 之后的值**。此后，服务端处于 `SYN-RECD` 状态。
  * 对应橙色箭头
* 客户端收到服务端发来的 `SYN` 号和 `ACK` 号之后，**会返回一个 `ACK` 号（数值上为在服务器发送过来的序列号的基础上加上 1 之后的值）**，此后客户端处于 `ESTABLISHED` 。到此为止，客户端部分的握手结束。
  * 对应绿色箭头
* 服务端在收到客户端发送过来的 `ACK` 号之后会进入 `ESTABLISHED` 。到此为止，服务端部分的握手结束。

整个握手过程，**客户端是一发一收**，**服务端也是一发一收**。均为一发一收，因此**握手的目的是保证双方均有发送数据和接受数据的能力**。

* 注：**三次握手阶段双方只会发送 TCP 头部信息**，这只是建立连接前的工作，不会发送数据



### 查看 TCP 状态

在 Linux 下，可以通过 `netstat -napt` 命令查看。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/10.jpg)



### TCP 分割数据

如果 HTTP 请求消息比较长，超过了 `Mss` 的长度，这个时候 TCP 就会将 HTTP 的数据拆成一块一块来发送，而不是全部发送。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/11.jpg)



* MSS 除去 IP 头部和 TCP 头部后的数据长度
* MTU 一个网络包的最大长度，以太网中为 1500 字节

HTTP 报文数据会被以 **MSS** 的数据长度进行拆分，拆分出来的每一块数据都会被放进单独的网络包中。也就是在 MSS 大小的数据前面加上 TCP 头部，之后交由 IP 模块来发送数据。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/12.jpg)



### TCP 段（也就是 TCP 报文）的生成

TCP 协议里面会有两个端口，一个是浏览器监听的端口（浏览器接收数据的端口，通常随机生成），另一个是 Web 服务器监听的端口（ HTTP 协议下的端口号是 80， HTTPS 协议下的端口号是 443 ）。

双方建立连接后，TCP 报文当中的数据部分为 「HTTP 报文加上应用数据部分」，再次基础上加上 TCP 头部就可以组成 TCP 段（也就是 TCP 报文）。

至此，网络包的报文如下：

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/13.jpg)





## IP



TCP 模块在**执行连接、收发、断开等**各阶段操作时，都需要委托 IP 模块将数据封装成**网络包**来发送给通信对象。



### IP包（IP 报文）的 IP 头部

IP 头部的格式如下：

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/14.jpg)



IP 协议里面需要有**源地址 IP** 和**目标地址 IP**

* 源地址 IP 为客户端输出的 IP 地址
* 目标地址 IP 为通过 DNS 域名解析得到 Web 服务器 IP 地址

因为 HTTP 报文是经过 TCP 协议传输的，所有在 IP 包头的**协议号**当中要填 06（十六进制），表示协议为 TCP。



### IP 源地址的判断

假设客户端存在多个网卡，就会有多个 IP 地址，那么源地址 IP 应该选择哪个？

这个时候我们可以通过**路由表**来判断应该使用哪一个网卡来作为源地址 IP

在 Linux 下，可以用 `route -n` 来查看系统当前的路由表

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/15.jpg)



假设 Web 服务器的目标地址为 `192.168.10.200` 。我们**拿这个目标地址进行运算**。

1. 先将 `192.168.10.200` 与第一条目的**子网掩码（Genmask）**进行**与运算**，其结果为 `192.168.10.0` ，而第一条目的 `Destination` 是 `192.168.3.0` ，二者并不匹配。
2. 再将 `192.168.10.200` 与第二条目的子网掩码进行与运算，结果为 `192.168.10.0` 刚好与第二条目的 `Destination` 向吻合。因此**将第二条目的网卡 `eth1` 的 IP 地址作为源地址 IP**。

如果所有条目都无法匹配，则会默认匹配第三个，这个是**默认网关**，它的目标地址和子网掩码都是 `0.0.0.0` 。

在这里，我们将 **Web 服务器的 IP 地址填入目标 IP 地址，将「对应网卡的 IP 地址」填入源 IP 地址 **。

**`Gateway` 就是路由器的 IP 地址**。上面匹配成功是将**网卡的 IP 地址作为源地址 IP ，不是将路由器的 IP 地址作为源地址 IP** 。

其具体匹配过程如下图：

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/16.jpg)



### IP 报文的生成

至此，网络包的报文如下：

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/17.jpg)



## MAC

生成 IP 头部之后，还需要在前面加上 **MAC 头部**。



### MAC 头部格式

MAC 头部为以太网所使用的头部，它包含接收方和发送发的 MAC 地址等信息。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/18.jpg)



在 MAC 包头里需要**发送方 MAC 地址**和**接收方 MAC 地址**，这主要是用于**两点之间的传输**。

一般在 TCP/IP 通信里， MAC 包头的**协议类型**只使用：

* `0800` 对应 IP 协议
* `0806` 对应 ARP 协议



### MAC 发送方和接收方地址如何确认

**发送方**的 MAC 地址的获取比较简单，MAC 地址是在网卡生产时写入到 ROM（内存）里的，只需要将这个数值读取出来就行。

**接收方**的 MAC 地址的获取就相对复杂。我们目前知道**目标的 IP 地址，但不知道目标的 MAC 地址**，这个时候就需要 **ARP 协议**来帮我们获取目标路由器的 IP 地址。

ARP 协议会在以太网中以**广播**的形式向所有以太网当中的设备发出请求，收到请求的**设备的 IP** 地址如果跟 ARP 所广播的 IP 地址相同，那么该设备将会返回自己的 MAC 地址给数据发送方的设备。

如果对方和自己处于同一个子网当中吗，那么通过上述操作就可以获得对方的 MAC 地址。之后，我们将该 MAC 地址写入**接收方的 MAC 地址**即可 。

当然，我们并不需要每次都去广播获权，操作系统会将本次的查询结果放在 **ARP 缓存**当中供以后使用，不过缓存也就几分钟而已。

那么整个发包过程可以概述为：

* 先查询 ARP 缓存，如果有目标的 MAC 地址的话就不需要进行 ARP 广播，直接将该地址写入 MAC 头部即可
* 如果 ARP 缓存当中不存在对方的 MAC 地址时，则通过 ARP 广播查询。

在 Liunx 下，我们可以使用 `arp -a` 来查询 ARP 缓存的内容

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/20.jpg)



### MAC 报文的生成 

至此，网络包的报文如下：

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/21.jpg)



## 网卡

网络包本质上只是一串二进制数字，这玩意是数字信号，并不能直接传输过去。因此我们需要将**数字信号转换成电信号**，而转换的工具便是**网卡**，控制网卡的是**网卡驱动程序**。

网卡驱动获取到网络包之后，会将其**复制**到网卡内的缓存区当中，接着会在其**开头加上「报头和起始帧分界符」，在末尾加上用于检测错误的「帧校验序列」**。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E5%8C%85.drawio.png)



* 起始帧分界符用于表示**这个包的起始位置**。
* 末尾的 FCS（帧校验序列）则用来**检查包在传输过程中是否损坏**。

网卡会将包转化成电信号，通过网线发出去。



## 交换机

交换机的设计是将网络包**原样**转发到目的地。交换机工作在 MAC 层，**并不涉及到 IP **，也称为**二层网络设备**。



### 交换机的包接收工作

当电信号到达网线接口时，交换机内部的模块会进行接收，**将电信号转化成数字信号**。

然后通过包末尾的 FCS 来校验错误，如果没问题则直接放到缓冲区。这一部分的操作与计算机的网卡基本相同，但二者不同的是：

* 计算机的网卡**本身具有 MAC 地址**，它可以通过检查收到的包的 MAC 地址来判断**这个包是不是发给自己的**，如果不是则直接丢弃，是的话便接收。
* 交换机的端口**并没有 MAC 地址**，**它不会核对包的接收方的 MAC 地址**，而是**将所有包全部放到缓冲区**。

将包放入缓冲区后，只需要查询 **MAC 地址表**当中是否有当前 MAC 地址的记录。

交换机的 MAC 地址表主要包含两个信息：

* 设备的 MAC 地址
* 该设备连接在交换机的哪个端口上（该 MAC 地址对应哪个端口）

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/23.jpg)

我们举个例子，如果接收方的 MAC 地址为 `00-02-B3-1C-9C-F9` ，则该 MAC 地址对应端口 3 ，因此交换机直接**将数字信号往端口 3 去发送**。

因此，**交换机会根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应端口**。

那么这里就有一个问题是：如果在 MAC 地址表当中找不到指定的 MAC 地址怎么办？

这种情况会对应两种可能：

* 具有该 MAC 地址的设备还没有向交换机发送过包
* 该设备一段时间内没有工作导致其地址被从交换机的 MAC 地址表中删除了

这种情况下，交换机将无法判断出应该将包转发到哪个端口，**只能将包转发到除了源端口以外的所有端口上**，这样无论该设备在哪个端口上就都可以收到这个包。

这样做并不会有任何的问题，因为以太网设计的原则是：**将包发送到整个网络，只有相应的接收者才接收这个包，其他的则直接忽略掉这个包**。

此外，如果接收方的 MAC 地址是一个**广播地址**，那么交换机也会将这个包**发送到除源端口以外的所有端口**。

以下两个为广播地址：

* MAC 地址：`FF:FF:FF:FF:FF:FF`
* IP 地址：`255.255.255.255`



## 路由器

### 路由器与交换机的区别

网络包经过交换机之后就会到达**路由器**，并在此被转发到下一个**路由器或者目标设备**。

这里转发的工作原理和交换机类似，也是通过查表来判断转发目标。

但在具体操作上，二者依旧有区别：

* 路由器是**基于 IP 设计的**，即**三层**网络设备，**路由器的各个端口都具有 MAC 地址和 IP 地址** 。
* 交换机是**基于以太网设计的**，即**二层**网络设备，**交换机的端口并不具有 MAC 地址** 。



### 路由器的基本原理

路由器的端口具有 MAC 地址，因此它能够**成为以太网的发送方和接收方**，它还具有 IP 地址，在这一点上它跟网卡差不多。

当转发包时，路由器会先从端口接收**发给自己的网络包**，然后通过**路由表**来查询转发目标，再通过相应端口将以太网包发送出去。



### 路由器的包接收操作



