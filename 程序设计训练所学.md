# using的用法

## 第一

> using namespace 名称空间


该用法将使得程序可以**直接使用名称空间当中的元素**，而不需要在使用的时候指定名称空间

```cpp
using namespace std
```
这样用可以直接使用名称空间`std`当中的内容，如`cin`、`cout`，而不需要写`std::cin`与`std::cout`

## 第二

给某一类型定别名，用法同`typedef`

> using 类型名 = 原类型名

```cpp
using nint = unsigned int; //nint相当于unsigned int
```

## 第三

在继承时，如果子类用`private`的继承方式去继承父类，那么父类当中`public`与`protect`权限下的成员在子类当中将会变为`private`权限。如果**我想让这些继承而来的成员继续作为`public`与`protect`权限出现**，那么我可以用`using`来从新声明。**`using`声明语句中名字的访问权限由该`using`声明语句之前的访问说明符决定**

```cpp
class base
{
public:
	int a;
protect:
	int b;
};
class son : private base
{
public:
	using base::a;
protect:
	using base::b;
};
```

> 上例中，变量`a`与`b`在子类当中应为`private`权限，但子类用来`using`关键字来从新声明该名字的访问权限，使得`a`变为`public`权限，`b`变为`protect`权限。


## 第四

在多态中，由于派生类可以重载基类当中的成员函数（这种情况一般是虚析构，即基类**没有加`virtual`关键字**，而派生类也可以选择性的重载基类的一些函数。如果基类是纯虚析构，那么派生类必须全部重载基类当中的纯虚函数），如果**派生类希望基类当中的函数对于它而言是可见的**（这里的可见指的是：如果我想通过派生类来调用基类的函数的话，我必须**要写两个作用域才可以调用**），那么它就要全部重载基类函数（在派生类当中该函数的写法与基类完全一致）或者一个也不重载。但有时一个派生类仅仅需要重写部分基类当中的函数，对于基类其他的成员函数并**不需要重写**，这个时候如果全部重写基类当中的函数就太繁琐了

这时`using`便派上用场了，我只需要为**重载的成员函数提供一条`using`声明，那么我就不需要重载全部版本了**

```cpp
class base
{
	void fun()
	{
		cout << "fun" << endl;
	}
	void fun(int)
	{
		cout << "fun(int)" << endl;
	}
};
class son : public base
{
	using base::fun;
};
```

>这里指定的是名字而不是形参列表，因此一条基类成员的`using`语句就可以将该函数**在基类中所有的重载实例全部**添加到派生类当中

---

