---
title: 动规--背包问题
tags: [背包, 动态规划, Algorithm]
categories: Algorithm Solution
---

### 0 - 1 背包

问题描述：

有 `N` 件物品和一个最多能背重量为 `W` 的背包。第i件物品的重量是 `weight[i]`，得到的价值是 `value[i] `。

**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大。



背包问题是典型的动态规划。在此，我们需要明确两个概念：**「选择」**和**「状态」**。

什么叫「选择」？对于一个物品 `i` ，我可以**选择**将它放入背包还是不放人背包。

而「选择」与「状态」之间的连续为：**「选择」会引发「状态」的改变**。基于这一点，这里的「状态」有：背包的重量、可供选择的物品。

这里你会问：背包当前的价值算不算是状态？

答案是：不能算，这只是某一个状态下所对应的值而已，仅仅是数值，不是状态。

在这里，我们可以给出 `dp` 数组的定义了：`dp[i][j]` 表示**在前 `i` 个物品中进行挑选，在背包容量为 `j` 的状态下的最大价值**。

然后，我们再看初始化。

显然，在前 0 个物品中挑选的最大价值是 0 。在背包容量为 0 的条件下挑选的最大价值也是 0 。故：`dp[0][j] = 0, dp[i][0] = 0` 。

然后我们来看状态转移方程的部分。

我们的递归从 1 开始，因此 `i - 1` 表示第 `i` 个物品。那么对于第 `i` 个物品就有选与不选两种「选择」。

在开始之前我需要强调的一点是：我目前是在考察第 `i` 个物品，也就是说我是**从状态 `i - 1` 去推状态 `i`** 。**放到 `dp` 数组里面就是通过 `dp[i - 1]` 求 `dp[i]`** （因为这里涉及偏移）。

* 不选第 `i` 个物品。那么 `dp[i][j] = dp[i - 1][j]` 。`j` 是不能变的啊，因为不选的话背包的容量不会发生改变。
* 如果选择第 `i` 个物品。那么状态 `i - 1` 对应 `dp` 数组应该是 `dp[i - 1][j - weight[i]]` ，即 `dp[i][j] = dp[i - 1][weight[i - 1]] + value[i - 1]` 。

这里就有问题了，你可能会问：为什么在状态 `i - 1` 下会用到状态 `i` 下的东西呢？这不就是从 `i` 推到 `i - 1` 了吗？

这个地方我的理解是：这不影响，我们目前知道的是状态 `i` 的重量一定比状态 `i - 1` 的重量要多 `weight[i - 1]` ，因为我把第 `i` 个物品加入到背包里面了。也就是说我们也可以写：`dp[i][j + weight[i - 1]] = dp[i - 1][j] + value[i - 1]` 。

那么到此为止，我对于这玩意所有的疑问都已经解决了，下面给出相应代码：

```cpp
int back(int N, int W, vector<int>& weight, vector<int>& value)
{
    vector<vector<int>>dp(N + 1, vector<int>(W + 1, 0));
    for (int i = 1; i <= N; i++)
    {
        for (int j = 1; j <= W; j++)
            if (j > weight[i - 1])
                dp[i][j] = max(dp[i - 1][j], 
                               dp[i - 1][j - weight[i - 1]] + value[i - 1]);
    }
    return dp[N][W];
}
```

