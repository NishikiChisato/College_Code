---
title: LC 1161.最大层内元素和
tags: [二叉树, Algorithm]
categories: Algorithm Solution
---

#### [1161. 最大层内元素和](https://leetcode.cn/problems/maximum-level-sum-of-a-binary-tree/)

给你一个二叉树的根节点 `root`。设根节点位于二叉树的第 `1` 层，而根节点的子节点位于第 `2` 层，依此类推。

请返回层内元素之和 **最大** 的那几层（可能只有一层）的层号，并返回其中 **最小** 的那个。


	输入：root = [1,7,0,7,-8,null,null]
	输出：2
	解释：
	第 1 层各元素之和为 1，
	第 2 层各元素之和为 7 + 0 = 7，
	第 3 层各元素之和为 7 + -8 = -1，
	所以我们返回第 2 层的层号，它的层内元素之和最大。



#### BFS



既然是找每一层的最大值，那么我们直接用层序遍历即可并用一个下标来记录当前层的最大和所对应的层数，最后返回即可。还蛮简单的

```cpp
class Solution {
public:
	int maxLevelSum(TreeNode* root)
	{
		if (root == NULL)
			return 0;
		queue<TreeNode*>que;
		que.push(root);
		int sum = 0;//记录每层的元素和
		int maxsum = INT32_MIN, index = 0;//记录最大那一层的元素和以及相应的下标
		int deep = 0;//记录层数
		while (!que.empty())
		{
			int size = que.size();
			deep++;
			for (int i = 0; i < size; i++)
			{
				TreeNode* cur = que.front();
				que.pop();
				sum += cur->val;
				if (cur->left)
					que.push(cur->left);
				if (cur->right)
					que.push(cur->right);
			}
			if (sum > maxsum)
			{
				maxsum = sum;
				index = deep;
			}
            sum = 0;
		}
		return index;
	}
};
```



#### DFS

当然，这道题我们也可以用递归来解决

这道题我们需要解决的问题只有一个：**记录每一层的所有元素和及该层的层数**。

那么，我们完全可以用一个数组来解决。用数组下标来表示层数，下标所对应的值表示该层所有元素的和，那么最后的结果就是这个数组中最大元素所对应的下标。

那么有一个问题是，**对于当前递归的到的这个元素，我该如何确定该将它加入到哪个下标当中去呢**。

显然，递归函数只有一个参数是满足不了我们的，我们还需要一个参数来记录当前层数。

当层数等于数组大小时，说明该元素在新的一层，需要插入到数组的末尾。

当层数小于数组大小时，直接让对应元素相加即可。

```cpp
class Solution {
public:
	vector<int>ret;

	void DFS(TreeNode* cur, int deep)
	{
		if (ret.size() == deep)
			ret.push_back(cur->val);//在后面插入
		else
			ret[deep] += cur->val;
		if (cur->left)
			DFS(cur->left, deep + 1);//这里不能写deep++, 因为会影响到下面cur右边的递归
		if (cur->right)              //这里不能写else, 因为我们需要保证该节点的两个子树都能递归到
			DFS(cur->right, deep + 1);
	}

	int maxLevelSum(TreeNode* root)
	{
		if (root == nullptr)
			return 0;
		DFS(root, 0);
		int index = 0;
		for (int i = 0; i < ret.size(); i++)
			if (ret[index] < ret[i])
				index = i;
		return index + 1;
	}
};
```



