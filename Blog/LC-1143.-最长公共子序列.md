---
title: LC 1143. 最长公共子序列
tags: [动态规划, Algorithm]
categories: Algorithm Solution
---

#### [1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)

给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ，返回 `0` 。

一个字符串的 **子序列** 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

- 例如，`"ace"` 是 `"abcde"` 的子序列，但 `"aec"` 不是 `"abcde"` 的子序列。

两个字符串的 **公共子序列** 是这两个字符串所共同拥有的子序列。

```
输入：text1 = "abcde", text2 = "ace" 
输出：3  
解释：最长公共子序列是 "ace" ，它的长度为 3 。
```



#### dp函数 + 备忘录

像这种子序列的题目，我们可以用两个指针分别来指向这两个字符串，然后定义一个 `dp` 函数： `int dp(string& s1, int i, string s2, int j)` 。它的意义为： `s1` 中区间 `[i, s1.length()]` 与 `s2` 中区间 `[j, s2.length()]`  当中的**最长公共子序列的值**。

明确了这个定义之后我们再看这个函数什么时候终止。显然，当 `i` 或者 `j` 走完的时候就应该停止，并且这个时候应该返回零。因为再检索后面就没有意义了。

之后就是最有意思的地方了——检索。这里我们分两种情况讨论：

* 当 `s1[i] == s2[j]` 时

这种情况很简单，我们只需要继续往后检索并再次基础上加一即可（如果只想到这一层的话后面是想不到的）

这里我们需要再多想一下：为什么可以加 1 ？

回顾 `dp` 函数的定义，加 1 就说明当前字符**处于**公共子序列中。

* 当 `s1[i] != s2[j]` 时

有了前面的铺垫，这里就会简单很多。这两个字符不相等，说明它们**至少一个不在**公共子序列中

 再此基础上，我们再分三类：

如果是 `s1[i]` 不在公共子序列中，那么我们让 `i + 1` 去检索 `i` 后面的内容即可

`s2[j]` 同理，让 `j + 1` 去检索 `j` 后面的内容。

如果两个都不在呢，那就全部加 1 嘛。

最后我们加个 `memo` 数组去重即可

```cpp
class Solution {
public:
	vector<vector<int>>memo;

	int dp(string& s1, int i, string& s2, int j)//从两字符串头部开始，i与j往后的最大公共子串的长度
	{
		if (i == s1.length() || j == s2.length())//到头来，不可能会有公共子串，返回0
			return 0;
		if (memo[i][j] != -1)
			return memo[i][j];
		if (s1[i] == s2[j])
			memo[i][j] =  1 + dp(s1, i + 1, s2, j + 1);//相等的话继续往后查找
		else
			memo[i][j] = Max(dp(s1, i + 1, s2, j), dp(s1, i, s2, j + 1), dp(s1, i + 1, s2, j + 1));
		return memo[i][j];
	}

	int Max(int a, int b, int c)
	{
		return max(a, max(b, c));
	}

	int longestCommonSubsequence(string text1, string text2)
	{
		int n = text1.length(), m = text2.length();
		memo.assign(n + 1, vector<int>(m + 1, -1));
		return dp(text1, 0, text2, 0);//求[0, s1.length()] 与 [0, s2.length()] 当中的最长公共子序列
	}
};    
```

时间复杂度：*O( min( n, m ) )* ，n、m 表示两字符串的长度。

空间复杂度：*O( min( n, m ) )*，同上。



#### dp 数组

我们来看如何用 dp 数组来解决这个问题。

在定义二维数组的时候，我们习惯写：

```cpp
int n = text1.length(), m = text2.length();
vector<vector<int>>dp(n + 1, vector<int>(m + 1, 1));
```

这么写的话就需要对相应的字符串进行**偏移**。

为什么？很简单，对于 `dp` 数组而言， **`dp[n][m]` 是有意义的而 `text1[n]` 、 `text2[m]` 则是无意义的**。显然，这里我们需要对两个字符串进行偏移才行。

具体做法是修改 `dp` 数组的定义。我们定义 `dp[i][j]` 表示 `text1` 在区间 `[0, i - 1]` 与 `text2` 在区间 `[0, j - 1]` 中的最长子序列（实际上我们只需要对两个字符串的下标进行偏移就行，当然是向左偏移，这样 `text1[n]` 就有意义了）。

然后我们来看是否需要初始化。

当我们进行偏移过后， `dp` 数组中的下标 1 对应 `text1` 或 `text2` 中的下标 0 。也就是说，`dp[0][j]` 与 `dp[i][0]` 会空出来。因此也不需要进行初始化。

那么总体代码如下：

```cpp
class Solution {
public:
	int longestCommonSubsequence(string text1, string text2)
	{
		int n = text1.length(), m = text2.length();
		vector<vector<int>>dp(n + 1, vector<int>(m + 1, 0));


		for (int i = 1; i <= n; i++)
		{
			for (int j = 1; j <= m; j++)
			{
				if (text1[i - 1] == text2[j - 1])//这里索引要有偏移，检测前一个是否相同
					dp[i][j] = dp[i - 1][j - 1] + 1;
				else dp[i][j] = Max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]);
			}
		}
		return dp[n][m];
	}

	int Max(int a, int b, int c)
	{
		return max(a, max(b, c));
	}
};
```

时间复杂度：*O( mn )*， 其中 m、n 分别是两个字符串的长度。

空间复杂度：*O( mn )* ，创建了一个二维数组，字母意义同上。

