---
title: C++ 类模板小结
tags: C++ Primer Plus
categories: Study Notes
---

# 模板具体化

类模板与函数模板很相似，都有隐式实例化，显示实例化、显示具体化，这些统称为具体化( implicit instantiation) 。类模板的声明用**泛型的方式来描述类**，而具体化则是以**具体的类型来生成对应的类声明**。



## 隐式实例化

在用类声明对象时，我们需要指定其类型，之后编译器会通过类模板来为该类型生成一个类定义（也就是类的具体化，类的模板参数变为已知），即：

```cpp
stack<int>st;//编译器会生成一个int类型的类定义，然后用该类定义来实例化对象
```

这里需要说明的是：类的具体化是指「用指定的类型通过类模板声明来生成对应类型的类定义」。

我们通常会写出一个带有模板参数的类声明（这个类当中的所有成员方法都写出了模板定义，但我们依旧称整个类为模板类声明），当我们给模板参数指定一个类型的时候，编译器会利用类模板声明自动生成该**类型**所对应的类模板定义（这个时候类模板中的所有模板参数替换为指定的类型）

这个地方，我们是需要**创建一个对象**之后才会发生隐式实例化，如果没有对象需要创建则不会发生隐式实例化，即：

```cpp
stack<int>pt*;//不会创建对象，自然也不会有隐式实例化，编译器不会为int生成一个类定义
```



那么为什么是「隐式」呢？

这里的**隐式**说的应该是类的具体化是隐式的。具体来说，由于**需要创建对象**，那么在创建对象之前就需要**有相应的类定义**，这个时候**类的「具体化」就会被隐式地执行**。

下面地显式实例化也是同理。虽然没有创建对象，但由于**显式**制定了类型，也就相当于**类的「具体化」会被显式执行**。



那么为什么要叫「实例化」呢，直接叫「隐式具体化」不就行了？

我们所说的实例化指的是**用类定义类创建一个对象**，「具体化」仅仅是生成对应的类定义，并不涉及到对象的创建。



然后，我们需要在这里说明一下什么叫「类声明」和「类定义」。我的理解是：类声明就是只写出类中方法的声明而没有给出定义，类定义是**在前者的基础上给出了类方法的定义**。

那么「类模板声明」和「类模板定义」就是：前者为**类定义**，不过类当中的类型为模板参数，后者为**类定义**并且类当中的类型为指定类型



## 显式实例化

显示实例化必须**放在类模板定义所处的名称空间中**。这种情况下，虽然没有创建对象但编译器**利用类模板声明**也会**生成对应类型的类定义**。

我们只需要用 template 来指定所需类型来声明类即可

```cpp
template class stack<int>;
```

这么做之后，**编译器会直接创建一个类型为 `int` 的类定义**，就算没有指定对象。



## 显式具体化

前面说过，**具体化就是用类模板声明来创建对应类型的定义**。有的时候，这种类模板定义并不能满足对于一些特定类型的需求。因此我们需要**为特定的类型单独生成其类模板定义**，这便是显式具体化。

```cpp
template<> class className<specialized-type-name>
{
    ...
};
```

当需要为 `speciailized-type-name` 创建对应的类模板定义时，编译器**不会通过类模板声明来创建**而是直接使用显式具体化得到的类定义（看到了吗，具体化就是生成对应类型的类定义）。



## 部分具体化

如果有多个模板参数，那么我们可以给部分模板参数指定类型，这便是「部分具体化」

```cpp
template<class T1, class T2>
class P {...};

template<class T1>//这个部分写的是没有被具体化的模板参数
class P<T1, int> //这个部分不用写 class
{...};
```

当然，有多个模板可供选择的话编译器会选择**具体化程度高的**。

我们也可以这样：

```cpp
template<class T> class P{...};
template<class T*> class P{...};

P<char> t1;//匹配第一个
P<char*> t2;//匹配第二个
```

我们还可以更骚：

```cpp
template<class T1, class T2, class T3> class P{...};//下面两个都是这个的特化
template<class T1. class T2> class P<T1, T2, T2>{...};
template<class T1> class P<T1, T1*, T1*>{...};
```



# 成员模板

一个类模板当中是可以嵌套另外一个类模板的，这一部分我们主要说明一下如何在类外定义这些东西

```cpp
template<class T>//类声明
class TP
{
private:
	template<class V>//这个地方不能写 T , 下面同理
	class HD;        
	HD<T>a;
	HD<T>b;

public:
	TP(T e1, T e2, T e3, T e4)
		: a(e1, e3), b(e2, e4)
	{  }

	void show() const;
	template<typename Y>
	Y cal();
};
```

这个例子基本上囊括全了，在类模板当中既有**类模板声明**也有**函数模板声明**。不管你怎么写，他们的在类外的定义总归是一样的

```cpp
template<class T>
template<class V>//同样，不能写 T
class TP<T>::HD //类的话前面就是 class ，函数的话前面就是返回值
{
public:
	HD(V e1, V e2 = e1)
		:a(e1), b(e2)
	{  }

	V re_a() const { return a; }
	V re_b() const { return b; }

private:
	V a, b;
};

template<class T>
template<typename Y>
Y TP<T>::cal()
{
	return a.re_a() + a.re_b() + b.re_a() + b.re_b();
}

template<class T>
void TP<T>::show()const
{
	cout << a.re_a() << " " << a.re_b() << endl;
	cout << b.re_a() << " " << b.re_b() << endl;
}
```

关于写了两层 `template` ，我需要说明一点的是：由于类内部的类 `HD` 只能由类名 `TP` 解析而得（因为模板是**嵌套**的，绝对不能用 `template T, template V` 这种，这就**不是嵌套了**），而关于类名 `TP` 必须要给出其模板参数类型才行，而类 `HD` 的定义本身也需要一层 `template` ，这便才有了两层。

我需要额外说明一点：这里的 HD 的模板参数跟 TP 的模板参数不同，当然也可以写成相同，这样的话只需要在类外写一层 `template` 就行。
