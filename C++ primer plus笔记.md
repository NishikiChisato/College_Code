# 函数



## 基础

### 函数是如何返回返回值的

通常，函数将返回值复制到指定的CPU寄存器或内存单元中。随后，调用该函数的程序查看该内存单元。函数原型（声明）告诉调用程序返回值的类型，函数定义命令被调用函数用什么类型的数据返回。即返回函数和调用函数必须就该内存单元的数据类型必须要达成一致

### 关于函数原型（声明）

* 为什么要用原型

函数原型将该函数的参数类型、数量和返回值类型告诉编译器，使得编译器可以正确解释它们

* 原型的语法

函数原型只需要提供函数返回值类型、函数名、参数列表（参数类型、数量）（不需要参数名称，实际上参数名称相当于**占位符**的存在）

当然，**函数的原型部分也可以不指定参数列表**，函数原型的参数部分为空表示参数默认为`void`，并不是不指定参数列表的意思。在C++中，**不指定参数列表应当用省略号：**

```cpp
void say_hi(...);
```

通常，仅当与接受可变参数的C函数（如printf)交互时才需要这么做

### 指针和const

如果数据类型本身不是指针，则可以将const数据或非const数据的**地址**赋值给被const修饰的指针，只能将非const数据的地址赋值给非const指针（不能将const数据的地址赋值给非const修饰的指针，这会使得const的状态很荒谬）

```cpp
    const int a = 10;
    int* pa = &a;//INVAILD
```

如果数据类型本身是指针，则可以将非const数据的地址赋值给const或非const修饰的指针，只能将const数据的地址赋值给const指针（不允许将const数据的地址赋值给非const修饰的指针，这一点与上面一致）



## 内联函数

编译过程的最终产物是可执行程序——一组机器指令的集合。当执行该程序时，操作系统会将这些指令都载入到内存当中，因此每一条指令都会对应一个内存编号。随后，计算机将逐步执行这些指令，（当遇到循环时）有时会向前、向后跳跃到特定地址执行对应的指令。函数的调用过程也是如此，当调用该函数时，操作系统会跳到该函数的起始地址开始执行，在函数结束时返回。

程序在跳跃执行函数的过程中，会产生一定的开销。当跳跃所需的开销大于实际执行的开销，并且在重复调用该函数的时候这会十分浪费资源。为了解决这一问题，C++内联函数提供了另一种选择。

编译内联函数时，**编译器会使用相应的函数代码来替换掉函数调用**，这样程序就不需要跳跃到其他内存地址来执行对应的代码了。因此内联函数的执行速度快于其他函数，但代价是会**带来更大的内存**。如果我在一段程序中调用了该函数十次，在编译后这里就会出现该函数代码的十个拷贝。

需要注意的是：

* 内联函数不应该过大，占用了多行就没有必要了
* 内联函数不能递归



## 引用变量

当我们声明一个变量时，编译器会为该变量分配一个内存地址，也就是说我可以通过该变量名来操作该内存地址当中的内容。引用变量的作用是**再给这块内存地址另外一个名字**，即我可以通过这两个不同的名字来操纵同一个内存地址，它们是完全等价的。

注：引用必须在其声明时就赋值，不能先初始化后赋值

```cpp
int rats;
int & rodent = rats;
int* const ptr = &rats;//引用等价于这个
```

因此，引用在对其初始化之后的值就不能被改变（这里指的是该引用的指向）

当函数的形参是一个引用类型的时候，对比不加引用的情况，其实参的要求更加严格。由于引用是实际上是一个变量的别名，因此函数的实参必须是变量，一个普通的数字是不允许的。

```cpp
int fun(int& e1);
fun(10);//Illeague
fun(a);//League
fun(a + 10);//Illeague
```

至于如何判断函数的实参是否会出问题，我们可以用一个很简单的方法——将其作为左值。如果是变量，那么它作为左值是被允许的，而非变量的数（如表达式）则不被允许

```cpp
a = 5;//League
a + 10 = 5;//Illeague
```

那么这里就引出了一个问题：什么是左值？常规变量和 const 变量都可以视为左值，因为它们都可以通过地址来访问。常规变量属于可修改的左值， const 变量属于不可修改的左值。

* 左值是允许通过地址来访问的，而右值不允许、

也就是说右值实际上是在一块临时的内存空间当中，上面的 fun(10) 与 fun(a + 10) ，这两个实参都是右值，它们存在于一个临时的内存空间当中

### 临时变量

如果实参与引用类型不匹配时，C++将生成临时变量，当然这么做只在引用被 const 修饰的时候才允许。如果引用参数为 const ，在以下两种情况下编译器会生成临时变量

* 实参类型正确，但不是左值
* 实参类型不正确，但可以转换成正确的类型

```cpp
void fun(const int& e1);
fun(10);//类型正确，但不是左值
fun(x + 10);//与上一种情况一样，会生成临时变量
fun((double)10.5);//类型不正确，但可以转换成正确的类型
```

总结一下就是，对于形参为 const 引用的函数，如果实参类型不匹配，编译器会生成临时变量使得形参的引用指向该临时变量，这里与按值传递就没有区别了



### 引用与继承

继承实际上就是派生类具有一些基类的性质。在引用这里，当一个函数是以基类引用作为形参时，**在传入的实参部分可以是基类，也可以是派生类**

举一个简单的例子是：ofstream 是 ostream 的派生类，当函数的形参部分写的是 ostream& 时，我既可以传入 ostream 类型的左值，也可以传入 ofstream 类型的左值



## 函数重载

函数发生重载的关键是函数的参数列表——也称为函数的特征标（function signature），只要两个函数的参**类型**与**数目**不同，那么它们就可以发生重载。

* C++不会依据变量名来发生函数重载
* C++不会依据返回值类型来发生函数重载

我们来看下面的几个函数

```cpp
void fun(int a, int b);
void fun(long a, int b);
void fun(double a, int b);
```

当我调用 fun( (unsigned int)10, 5 ) 时，它不与任何一个函数原型相匹配。当出现没有原型与之匹配时，C++会尝试使用**标准类型转换**强制进行匹配。

放在这个例子当中，10可以被转换成三种不同的类型，这将分别对应三种不同的接口。因此在这种情况下，C++会拒绝这种函数调用，将其视为错误

有一点需要注意的是，编译器在检查特征标时，会将***类型引用**和**类型**视为同一个特征标*，即不能通过引用来发生重载。考虑下面的例子

```cpp
void fun(int a);
void fun(int& a);
```

当我调用 fun(10) 时，确实会走入不同的接口，但是当我调用 fun(a) 时，两个接口都可以使用，这样就会导致错误，因此我们应当禁止这种行为的发生。

函数的形参部分是否含有 const 是可以发生重载的，原因在于**将 const 对象的值赋给 non-const 对象是合法的，但将 non-const 对象的值赋给 const 对象则是非法的**

实际上，我们可以通过默认参数的形式来替换掉函数重载，这样只需要写一份代码，编译时也只需要分配一份内存。但如果参数的类型不一致，那就乖乖地用函数重载吧



## 函数模板

函数模板是允许重载的，并且**模板参数不一定非得是模板参数类型**，例如：

```cpp
template<typename T>
void swap(T& a, T& b);
template<typename T>
void swap(T&a, T&b, int c);//最后一个参数类型可以不是模板参数类型
```



当然，模板是有其局限性的。由于模板参数类型可以代表所有的类型，但有些类型可能并不支持一些运算（例如 class 就不支持+）。当然，C++允许运算符重载，这是一种解决办法，但这里要介绍另一种——为特定类型提供具体化模板



### 显示具体化

首先有以下三点原则：

* 对于给定的函数名，可以有其非模板函数，模板函数，显示具体化模板函数及其重载版本
* 显示具体化要以 template<> 开头，并在参数部分指出其类型
* 非模板函数优先于常规模板函数和具体化模板函数，具体化模板函数优先于常规模板函数

假设我们有一个 class ：

```cpp
class KA {...};
```

对于上面的 swap 函数，其显示具体化模板为：

```cpp
template<typename T>
void swap(T& a, T& b);//常规模板
template<> void swap<KA>(KA& a, KA& b);//具体化模板
template<> void swap(KA& a, KA& b);//也可以写出这样
```



### 实例化与具体化

在代码中包含函数模板本身**并不会生成函数定义**，他只是一个用于**生成函数定义的方案**。当编译器用模板为特定的类型生成函数定义时，得到的是模板实例（这里编译器为自定义类型 KA 生成的函数定义称为**模板实例**，该实例使用 KA 类型）。**模板并非函数定义，但使用 int 的模板实例是函数定义**。

**编译器之所以知道需要为该类型生成对应的函数定义，是因为程序在调用模板函数时提供了具体的类型，因此也称这种实例化方式为隐式实例化**

简单来说，隐式实例化是**用该函数模板来生成特定类型的函数定义，该类型来自于函数调用**。既然有隐式实例化，那么自然也有显示实例化。这意味着可以直接命令编译器创建特定的类型，其语法是——在原函数模板的基础上指定其类型，并在最前面加上 template

```cpp
template<typename T>
void Swap(T& a, T& b);//函数模板的声明

template void Swap<int>(int& a, int& b);//显示实例化的声明
```

看到上述声明后，编译器将会**用函数模板来生成一个使用 int 类型的实例**，再说一次，是用函数模板来生成一个使用 int 类型的实例。

我们一般会**将显示实例化的声明放在头文件内**

于显示实例化不同的是，显示具体化使用的是下面两个**等价**声明

```cpp
template<> void Swap<int>(int& a, int& b);
template<> void Swap(int& a, int& b);
```

区别在于，这两个声明的意思是：**不要使用模板来生成对应的函数定义，而是使用专门为 int 类型显示定义的函数定义**。看到区别了吗？显示具体化直接绕过了通过模板生成函数定义这一步骤。显示具体化的 template 后面会带有 <> ，而显示实例化则没有。

* 注：不允许在一个文件内同时出现同一类型的显示具体化和显示实例化

隐式实例化、显示具体化、显示实例化总称为具体化

| template | 隐式实例化 | 显示实例化 | 显示具体化 |
|:----------:|:----------:|:-------------:|:--------------:|
| template<typename T> void Swap(T& a, T&b) | Swap(a, b)  ( a, b is int ) | template void Swap<char>(char& a, char& b) | template<> Swap<short>(short& a, short& b) or template<> Swap(double& a, double& b) |

```cpp
template<typename T>
void Swap(T& a, T& b);//其他类型走这条，隐式实例化
template void Swap<int>(int& a, int& b);//这玩意只是声明，强制编译器用模板来生成 int 实例
template<> void Swap<short>(short& a, short& b);//short 类型走这条，显示具体化
```



我们来进一步区分这三者

```cpp
template<typename T>
T Lesser(const T& a, const T& b)//函数模板
{
	cout << "Template" << endl;
	return a < b ? a : b;
}

int Lesser(const int& a, const int& b)//函数重载
{
	cout << "Overload" << endl;
	return a < b ? a : b;
}

template short Lesser<short>(const short& a, const short& b);//显示实例化声明，放在头文件

template<> double Lesser(const double& a, const double& b)//显示具体化
{
	cout << "Specialization" << endl;
	return a < b ? a : b;
}

int main()
{
	int a = 5, b = 10;
	short n = 1, m = 2;
	double x = 3, y = 6;
	cout << Lesser(a, b) << endl;
	cout << Lesser(n, m) << endl;
	cout << Lesser(x, y) << endl;

	cout << Lesser<>(a, b) << endl;//前两个函数模板
	cout << Lesser<>(n, m) << endl;
	cout << Lesser<>(x, y) << endl;//显示具体化

	cout << Lesser<int>(a, b) << endl;//全部都是函数模板
	cout << Lesser<int>(n, m) << endl;
	cout << Lesser<int>(x, y) << endl;//三者都是显示实例化，这是因为指定了模板参数类型

	return 0;
}
```

如果我在调用的时候**指定了参数类型，那么就是显示实例化，如果没有，则为隐式实例化**。



### decltype 和 后置返回类型（均为C++11）

考虑下面这个问题

```cpp
template<typename T1, typename T2>
void fun(T1 a, T2 b)
{
    x = a + b;
}
```

那么 x 应该为什么类型？

显然，在模板参数不确定的时候，我们根本没办法来判断。

这个时候， decltype 则解决了这个问题，我们可以这么使用：

```cpp
int x;
decltype(x) y
```

这里表示，**使 y 的类型跟 x 的相同**。对于上面那个问题，我们可以这么写：

```cpp
decltype(a + b) x = a + b;//这表示 x 的类型与 a + b 相同
```

现有声明：*decltype ( expression ) var* ，则 var 的类型按如下原则确定

* 如果 expression 是一个没有括号括起的标识符，则 var 的类型与标识符的类型相同，包括 const 等限定符
* 如果 expression 是一个函数调用，则 var 的类型与函数的返回值相同
  * **这里只是检查函数的返回类型，不会实际调用函数**
* 如果 espression 是一个左值，则 var 为指向其类型的引用
* 如果前面的条件都不满足，则 var 的类型与 expression 相同

对于上面那个函数，我们目前解决的是 x 的类型的问题，但该函数的返回值仍然不确定，但可以明确的是，返回值的类型一定与 x 相同，而 x 的类型又依靠 a + b 。

C++11提供一种叫后置返回类型的操作，即：

```cpp
auto fun(int a, int b) -> double
```

这样我们可以将返回值的类型写在后面，而 **auto 是占位符**。同理，对于上面那个问题，我们可以：

```cpp
auto fun(T1 a, T2 b) -> decltype(a + b)
{
    return a + b;
}
```



# 内存模型与名称空间



## 单独编译

在头文件中，我们可以包含：

* 函数原型
* 使用 #define 或 const 定义的符号常量
* 结构声明
* 类声明
* 模板声明
* 内联函数

在包含我们自己写的头文件是，要用 "" ，而不是 <> 。如果是用尖括号，则编译器会去存储标准头文件的目录下查找，如果是用双引号，则编译器会先在源代码目前去查找头文件，如果找不到才会去标准头文件目录下去查找

在C++中，我们需要尽可能避免多次包含头文件，具体方法如下

```cpp
#ifndef HHDD__ //如果没有定义 HHDD__ 则会执行下面的代码（到 endif 为止）
#define HHDD__
//...
#endif
```



## 存储持续性、作用域和链接性

C++使用三种（C++11是4四种）不同的方案来存储数据，它们的区别在于**数据保留在内存当中的时间**

* 自动存储持续性：在函数定义中声明的变量（包括函数参数）的存储连续性为自动的。当执行完函数或代码块时，它们的内存会自动释放
* 静态存储持续性：在函数定义外定义的变量或者用 static 定义的变量。它们在程序运行的整个期间都存在
* 动态存储持续性：用 new 所分配的内存将会一直存在，直到将这块内存 delete 掉
* 线程存储持续性（C++11）：如果变量是使用 thread_local 声明的，则其声明周期与所属线程一样长

### 作用域与链接

**作用域描述了名称在文件的多大范围内可见**。如，我在一个源文件的中间定义了一个变量，那么从中间到结尾该变量均可用，这里也是该变量的作用域，而从文件开头到中间则不是它的作用域

**链接性描述了名称如何在不同文件间共享**。**链接性为外部的名称可以在文件间共享，链接性为内部的名称只能由该文件当中的函数共享**。对于上面那个例子，该变量在当前源文件中使用的范围，这关乎它的作用域，而其他文件是否可以使用该变量则关乎它的链接性

* 全局变量的作用域为其定义位置到文件结尾
* 在类中声明的成员的作用域为整个类
* 在名称空间中声明的变量的作用域为整个名称空间（全局作用域可以看出名称空间作用域的特例）
* 函数的作用域可以是整个类或者整个名称空间，但不能是局部的

### 自动存储持续性

在函数中声明的变量和函数参数的**存储持续性为自动**，**作用域为局部**、**不具备链接性**。我们直接看下面这个例子：

```cpp
int main()
{
	int x = 5;
	cout << x << endl;
	cout << (int*)&x << endl;
	{
		int x = 10;
		cout << x << endl;
		cout << (int*)&x << endl;
	}
	cout << x << endl;
	cout << (int*)&x << endl;
	return 0;
}
```

* 注：花括号可以单独使用，其括起来的部分为一个代码块

在进入 main 函数的时候，定义了一个 x 。在进入代码块的时候，又定义了一个 x 。后定义的 x 由于处在代码块中，它会遮掩（替换）掉原来的 x 。也就是说，这个 x 并不是对原本 x 的赋值而是重新开辟了一块内存。

**两个 x 的作用域不同，因此它们存储的位置也不一样（尽管名称相同，但同一时间只会使用一个，因为存在遮掩），而如果它们的作用域相同，则后面的 x 为赋值**

在C++11中， auto 用于自动类型推断，在以前版本的C++与C中，它用于显示指出变量为自动存储

在C++11中，register 用于显示指出变量是自动的。使用它的原因是：程序员想使用一个自动变量，这个变量的名称可能与外部变量相同。register 原先的用法为：建议编译器用寄存器来存储自动变量



# 类继承



派生类具有以下特征

* 派生类对象存储了基类数据成员（**派生类继承了基类的实现**）
* 派生类对象可以使用基类的方法（**派生类继承了基类的接口**）

派生类不能访问基类的 private 成员，**只能通过基类方法进行访问**，这也是为什么派生类也会存在基类当中的 private 成员

* 基类当中的变量通常是 private 权限，它们的赋值主要依靠对外提供的方法（构造函数等）。派生类继承过了之后也同样只能靠这些方法来进行访问这些 private 权限的变量。
* **派生类的构造函数必须使用基类的构造函数**，通常是在派生类构造函数的初始化列表调用基类的构造函数。
  * 如果在派生类的构造函数（默认构造、有参构造、拷贝构造都一样）处没有调用基类的构造函数，那么编译器会**自动调用基类的默认构造函数**

```cpp
class Base
{
public:
	Base(int rhs)
		: x(rhs)
	{

	}
private:
	int x;
};

class Derived : public Base
{
public:
	Derived(int rh, int ch)
		: Base(ch), a(rh)
	{

	}
private:
	int a;
};
```

对于一个基类及其派生类，我们通常会将**它们的声明全部放在同一个头文件**，**它们的实现全部放在同一个源文件**



基类的指针或引用可以指向派生类对象，但是**该指针或引用只能调用基类的方法**，**不能调用子类的方法**（不涉及虚函数并且基类方法为 public 权限）

* 基于这一点，我们可以用派生类对象来对基类进行赋值

```cpp
Derived d(10, 5);
Base b(d);
```

这是因为基类的拷贝构造函数的声明为：`Base(const Base&)` ，**形参部分为基类的引用，它可以指向一个派生类的对象**。在这里指向的派生类对象是 d 。**因此可以通过派生类对象来对基类进行赋值**（*copy* 构造和 *copy assignment* 操作符都一样） 











