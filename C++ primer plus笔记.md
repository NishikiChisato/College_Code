# 函数



## 基础

### 函数是如何返回返回值的

通常，函数将返回值复制到指定的CPU寄存器或内存单元中。随后，调用该函数的程序查看该内存单元。函数原型（声明）告诉调用程序返回值的类型，函数定义命令被调用函数用什么类型的数据返回。即返回函数和调用函数必须就该内存单元的数据类型必须要达成一致

### 关于函数原型（声明）

* 为什么要用原型

函数原型将该函数的参数类型、数量和返回值类型告诉编译器，使得编译器可以正确解释它们

* 原型的语法

函数原型只需要提供函数返回值类型、函数名、参数列表（参数类型、数量）（不需要参数名称，实际上参数名称相当于**占位符**的存在）

当然，**函数的原型部分也可以不指定参数列表**，函数原型的参数部分为空表示参数默认为`void`，并不是不指定参数列表的意思。在C++中，**不指定参数列表应当用省略号：**

```cpp
void say_hi(...);
```

通常，仅当与接受可变参数的C函数（如printf)交互时才需要这么做

### 指针和const

如果数据类型本身不是指针，则可以将const数据或非const数据的**地址**赋值给被const修饰的指针，只能将非const数据的地址赋值给非const指针（不能将const数据的地址赋值给非const修饰的指针，这会使得const的状态很荒谬）

```cpp
    const int a = 10;
    int* pa = &a;//INVAILD
```

如果数据类型本身是指针，则可以将非const数据的地址赋值给const或非const修饰的指针，只能将const数据的地址赋值给const指针（不允许将const数据的地址赋值给非const修饰的指针，这一点与上面一致）



## 内联函数

编译过程的最终产物是可执行程序——一组机器指令的集合。当执行该程序时，操作系统会将这些指令都载入到内存当中，因此每一条指令都会对应一个内存编号。随后，计算机将逐步执行这些指令，（当遇到循环时）有时会向前、向后跳跃到特定地址执行对应的指令。函数的调用过程也是如此，当调用该函数时，操作系统会跳到该函数的起始地址开始执行，在函数结束时返回。

程序在跳跃执行函数的过程中，会产生一定的开销。当跳跃所需的开销大于实际执行的开销，并且在重复调用该函数的时候这会十分浪费资源。为了解决这一问题，C++内联函数提供了另一种选择。

编译内联函数时，**编译器会使用相应的函数代码来替换掉函数调用**，这样程序就不需要跳跃到其他内存地址来执行对应的代码了。因此内联函数的执行速度快于其他函数，但代价是会**带来更大的内存**。如果我在一段程序中调用了该函数十次，在编译后这里就会出现该函数代码的十个拷贝。

需要注意的是：

* 内联函数不应该过大，占用了多行就没有必要了
* 内联函数不能递归



## 引用变量

当我们声明一个变量时，编译器会为该变量分配一个内存地址，也就是说我可以通过该变量名来操作该内存地址当中的内容。引用变量的作用是**再给这块内存地址另外一个名字**，即我可以通过这两个不同的名字来操纵同一个内存地址，它们是完全等价的。

注：引用必须在其声明时就赋值，不能先初始化后赋值

```cpp
int rats;
int & rodent = rats;
int* const ptr = &rats;//引用等价于这个
```

因此，引用在对其初始化之后的值就不能被改变（这里指的是该引用的指向）

当函数的形参是一个引用类型的时候，对比不加引用的情况，其实参的要求更加严格。由于引用是实际上是一个变量的别名，因此函数的实参必须是变量，一个普通的数字是不允许的。

```cpp
int fun(int& e1);
fun(10);//Illeague
fun(a);//League
fun(a + 10);//Illeague
```

至于如何判断函数的实参是否会出问题，我们可以用一个很简单的方法——将其作为左值。如果是变量，那么它作为左值是被允许的，而非变量的数（如表达式）则不被允许

```cpp
a = 5;//League
a + 10 = 5;//Illeague
```

那么这里就引出了一个问题：什么是左值？常规变量和 const 变量都可以视为左值，因为它们都可以通过地址来访问。常规变量属于可修改的左值， const 变量属于不可修改的左值。

* 左值是允许通过地址来访问的，而右值不允许、

也就是说右值实际上是在一块临时的内存空间当中，上面的 fun(10) 与 fun(a + 10) ，这两个实参都是右值，它们存在于一个临时的内存空间当中

### 临时变量

如果实参与引用类型不匹配时，C++将生成临时变量，当然这么做只在引用被 const 修饰的时候才允许。如果引用参数为 const ，在以下两种情况下编译器会生成临时变量

* 实参类型正确，但不是左值
* 实参类型不正确，但可以转换成正确的类型

```cpp
void fun(const int& e1);
fun(10);//类型正确，但不是左值
fun(x + 10);//与上一种情况一样，会生成临时变量
fun((double)10.5);//类型不正确，但可以转换成正确的类型
```

总结一下就是，对于形参为 const 引用的函数，如果实参类型不匹配，编译器会生成临时变量使得形参的引用指向该临时变量，这里与按值传递就没有区别了



### 引用与继承

继承实际上就是派生类具有一些基类的性质。在引用这里，当一个函数是以基类引用作为形参时，**在传入的实参部分可以是基类，也可以是派生类**

举一个简单的例子是：ofstream 是 ostream 的派生类，当函数的形参部分写的是 ostream& 时，我既可以传入 ostream 类型的左值，也可以传入 ofstream 类型的左值



## 函数重载

函数发生重载的关键是函数的参数列表——也称为函数的特征标（function signature），只要两个函数的参**类型**与**数目**不同，那么它们就可以发生重载。

* C++不会依据变量名来发生函数重载
* C++不会依据返回值类型来发生函数重载

我们来看下面的几个函数

```cpp
void fun(int a, int b);
void fun(long a, int b);
void fun(double a, int b);
```

当我调用 fun( (unsigned int)10, 5 ) 时，它不与任何一个函数原型相匹配。当出现没有原型与之匹配时，C++会尝试使用**标准类型转换**强制进行匹配。

放在这个例子当中，10可以被转换成三种不同的类型，这将分别对应三种不同的接口。因此在这种情况下，C++会拒绝这种函数调用，将其视为错误

有一点需要注意的是，编译器在检查特征标时，会将***类型引用**和**类型**视为同一个特征标*，即不能通过引用来发生重载。考虑下面的例子

```cpp
void fun(int a);
void fun(int& a);
```

当我调用 fun(10) 时，确实会走入不同的接口，但是当我调用 fun(a) 时，两个接口都可以使用，这样就会导致错误，因此我们应当禁止这种行为的发生。

函数的形参部分是否含有 const 是可以发生重载的，原因在于**将 const 对象的值赋给 non-const 对象是合法的，但将 non-const 对象的值赋给 const 对象则是非法的**

实际上，我们可以通过默认参数的形式来替换掉函数重载，这样只需要写一份代码，编译时也只需要分配一份内存。但如果参数的类型不一致，那就乖乖地用函数重载吧
