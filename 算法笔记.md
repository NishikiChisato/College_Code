## 算法性能分析
## 大O的定义

+ 大O的定义指的是一个算法最坏的运行时间的上界，而我们通常说所的时间复杂度为一般情况，并不是严格的上界

+ 由于时间复杂度会忽略常数项，**因此并不是时间复杂度越低越好**
	+ 这是因为大O衡量的是数据量级非常大的情况下所表现出来的时间复杂度，此时常数项已经不起作用
	+ 对于一个复杂的大O表达式，我们只取最高量级的数并且忽略掉它的常数


###一个例子

找出n个字符串中相同的两个字符串（假设这里只有两个相同的字符串）

*通过暴力枚举的话需要O(n^2)，但这里涉及到两个字符串的逐字节比较的问题，因此需要再乘上字符串的长度m，即O(m * n^2)*

*如果我们采取先排序再查找的思路，对于快排而言，由于是字符串排序，时间复杂度为O(m * n * logn)，由于是按照字典序排列的，因此相同的两个字符串是排在一起的，因此只需在在排序的基础上加上遍历n个字符串与比较两个字符串所花的时间即可，因此总时间复杂度为O(m * n * logn + m * n)，比直接暴力枚举要快*

---

##递归算法的时间复杂度分析

+ 递归算法时间复杂度本质上是看`递归的次数 * 每次递归中的操作次数`


例如，我需要求x的n次方

```cpp
int fact(int x, int n)
{
	int temp = 1;
	for (int i = 0; i < n; i++)
		temp *= x;
	return temp;
}
```

我们可以写出该代码的递归代码

```cpp
int fact1(int x, int n)
{
	if (n == 0)
		return 1;
	else
		return fact1(x, n - 1) * n;
}
```

该代码的执行次数为n-1，每一次只执行一次乘法，因此总的时间复杂度为O(n)

```cpp
int fact2(int x, int n)
{
	if (n == 0)
		return 1;
	if (n & 1)//n is odd
		return fact2(x, n / 2) * fact2(x, n / 2) * x;
	else
		return fact2(x, n / 2) * fact2(x, n / 2);
}
```

**满二叉树相关结论**

`
* 二叉树的层数从1开始计算，深度为最大的层数
* 第k层最多有2的k-1次方个节点
* 总节点为n的满二叉数，其深度为logn下取整加1
* 若满二叉树的深度为h，则其总结点个数为2的h次方减1
`

该代码可以看成一个满二叉树，即：

![满二叉树](https://img-blog.csdnimg.cn/20201209193909426.png)

设x为总节点个数，h为满二叉树的深度，有`x = 2^h - 1, h = log 2 n + 1`
带入得到`x = 2n - 1`因此时间复杂度为O(n)

上面的递归中`fact2`算了两次，其实我们可以用一个变量记录它的值，然后让该变量自乘一次便可
```cpp
int fact3(int x, int n)
{
	if (n == 0)
		return 1;
	int temp = fact3(x, n / 2);
	if (n & 1)//n is odd
		return temp * temp * x;
	else
		return temp * temp;
}
```

这里的递归次数为`O(logn)`，每一次递归乘法的运算为`O(2)`，因此总的时间复杂度为`O(logn)`


# 数组

## 二分查找的写法

二分查找有两种区间写法，左闭右闭与左闭右开。对于循环部分的判断以及mid的跳转一定要按照区间来写

### 左闭右闭

左闭右闭说明了**区间的左右端点都在数组当中有数值对应**，即左端点对应第一个数，右端点对应最后一个数

* 对于循环部分，应写`while(left <= right)`。这是因为当`left = right`时，区间依旧有意义（它是一个点）

* 对于mid的跳转部分，应写`left = mid + 1`。这是因为如果`while(nums[mid] < target)`时，说明`nums[mid]`一定不是target，并且不需要再去检测`nums[mid]`，即区间的左端点直接跳到`mid + 1`就行

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) 
    {
        int left = 0, right = nums.size() - 1;//闭区间[left,right]写法，nums[right]为数组最后一个元素
        while (left <= right)//对于区间[left,right]而言，区间左端点left与右端点right重合依旧有意义
        {
            int mid = right + (left - right) >> 1;//直接用加号会溢出
            if (nums[mid] > target)//nums[mid]一定不是target，表明target在[left,mid-1]当中
                right = mid - 1;
            else if (nums[mid] < target)//nums[mid]一定不是target，target落在[mid+1,right]中
                left = mid + 1;
            else return mid;
        }
        return -1;//循环结束，说明没有找到，直接返回-1
    }
};
```

### 左闭右开

左闭右开说明**区间的右端点不是数组最后一个元素，而是最后一个元素的下一个**，即`右端点-1`才是数组当中最后一个元素

* 对于循环部分，写`while(left < right)`。因为当`left = right`时，区间无意义

* 对于区间左端点的跳转部分，当`while(nums[mid] < target)`时，`nums[mid]`不是target，由于区间是**左闭**的属性，因此`left = mid + 1`

* 对于区间右端点的跳转部分，当`while(nums[mid] > target)`时，`nums[mid]`不是target，但由于区间右端点必须是开区间，因此`right = mid`

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) 
    {
        int left = 0, right = nums.size();
        while (left < right)
        {
            int mid = right + (left - right) >> 1;
            if (nums[mid] > target)//target落在区间[left,mid)当中，由于右端点不在检测数组内，因此right = mid
                right = mid;
            else if (nums[mid] < target)//target落在区间(mid,right)，由于左端点为闭区间，因此left = mid + 1
                left = mid + 1;
            else return mid;
        }
        return -1;
    }
};
```

**二分查找本质上是对查找区间的不断缩小**，最终一定会变成区间含有三个或者四个元素的情况（区间两端点均为闭区间）。

* 对于前者，下一步的`left`或者`right`将会重合。假设`left=0, right=2`，这时`mid=1`，即与`target`比较的元素为**区间的中点**。那么下一步将会变成`left=0, right=0`，即二者重合，在进行一次判断，这时会产生`left>right`

* 对于后者，假设`left=0, right=3`，这时`mid=1`，即与`target`比较的元素为**中间偏右**。下一步将变成`left=0, right=0`，二者重合，之后的情况与上面一样。

