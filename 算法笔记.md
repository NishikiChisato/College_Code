## 算法性能分析
## 大O的定义

+ 大O的定义指的是一个算法最坏的运行时间的上界，而我们通常说所的时间复杂度为一般情况，并不是严格的上界

+ 由于时间复杂度会忽略常数项，**因此并不是时间复杂度越低越好**
	+ 这是因为大O衡量的是数据量级非常大的情况下所表现出来的时间复杂度，此时常数项已经不起作用
	+ 对于一个复杂的大O表达式，我们只取最高量级的数并且忽略掉它的常数


### 一个例子

找出n个字符串中相同的两个字符串（假设这里只有两个相同的字符串）

*通过暴力枚举的话需要O(n^2)，但这里涉及到两个字符串的逐字节比较的问题，因此需要再乘上字符串的长度m，即O(m * n^2)*

*如果我们采取先排序再查找的思路，对于快排而言，由于是字符串排序，时间复杂度为O(m * n * logn)，由于是按照字典序排列的，因此相同的两个字符串是排在一起的，因此只需在在排序的基础上加上遍历n个字符串与比较两个字符串所花的时间即可，因此总时间复杂度为O(m * n * logn + m * n)，比直接暴力枚举要快*

---

##递归算法的时间复杂度分析

+ 递归算法时间复杂度本质上是看`递归的次数 * 每次递归中的操作次数`


例如，我需要求x的n次方


```cpp
int fact(int x, int n)
{
int temp = 1;
for (int i = 0; i < n; i++)
	temp *= x;
return temp;
}
```


我们可以写出该代码的递归代码


```cpp
int fact1(int x, int n)
{
if (n == 0)
	return 1;
else
	return fact1(x, n - 1) * n;
}
```


该代码的执行次数为n-1，每一次只执行一次乘法，因此总的时间复杂度为O(n)

```cpp
int fact2(int x, int n)
{
if (n == 0)
	return 1;
if (n & 1)//n is odd
	return fact2(x, n / 2) * fact2(x, n / 2) * x;
else
	return fact2(x, n / 2) * fact2(x, n / 2);
}
```

---


**满二叉树相关结论**

`
* 二叉树的层数从1开始计算，深度为最大的层数
* 第k层最多有2的k-1次方个节点
* 总节点为n的满二叉数，其深度为logn下取整加1
* 若满二叉树的深度为h，则其总结点个数为2的h次方减1
`

该代码可以看成一个满二叉树，即：

![满二叉树](https://img-blog.csdnimg.cn/20201209193909426.png)

设x为总节点个数，h为满二叉树的深度，有`x = 2^h - 1, h = log 2 n + 1`
带入得到`x = 2n - 1`因此时间复杂度为O(n)

上面的递归中`fact2`算了两次，其实我们可以用一个变量记录它的值，然后让该变量自乘一次便可

```cpp
int fact3(int x, int n)	
{
if (n == 0)
	return 1;
int temp = fact3(x, n / 2);
if (n & 1)//n is odd
	return temp * temp * x;
else
	return temp * temp;
}
```


这里的递归次数为`O(logn)`，每一次递归乘法的运算为`O(2)`，因此总的时间复杂度为`O(logn)`

---


# 数组

## 二分查找的写法

二分查找有两种区间写法，左闭右闭与左闭右开。对于循环部分的判断以及mid的跳转一定要按照区间来写

### 左闭右闭

左闭右闭说明了**区间的左右端点都在数组当中有数值对应**，即左端点对应第一个数，右端点对应最后一个数

* 对于循环部分，应写`while(left <= right)`。这是因为当`left = right`时，区间依旧有意义（它是一个点）

* 对于mid的跳转部分，应写`left = mid + 1`。这是因为如果`while(nums[mid] < target)`时，说明`nums[mid]`一定不是target，并且不需要再去检测`nums[mid]`，即区间的左端点直接跳到`mid + 1`就行

```cpp

int search(vector<int>& nums, int target) 
{
    int left = 0, right = nums.size() - 1;//闭区间[left,right]写法，nums[right]为数组最后一个元素
    while (left <= right)//对于区间[left,right]而言，区间左端点left与右端点right重合依旧有意义
    {
        int mid = right + (left - right) >> 1;//直接用加号会溢出
        if (nums[mid] > target)//nums[mid]一定不是target，表明target在[left,mid-1]当中
            right = mid - 1;
        else if (nums[mid] < target)//nums[mid]一定不是target，target落在[mid+1,right]中
            left = mid + 1;
        else return mid;
    }
    return -1;//循环结束，说明没有找到，直接返回-1
}

```

### 左闭右开

左闭右开说明**区间的右端点不是数组最后一个元素，而是最后一个元素的下一个**，即`右端点-1`才是数组当中最后一个元素

* 对于循环部分，写`while(left < right)`。因为当`left = right`时，区间无意义

* 对于区间左端点的跳转部分，当`while(nums[mid] < target)`时，`nums[mid]`不是target，由于区间是**左闭**的属性，因此`left = mid + 1`

* 对于区间右端点的跳转部分，当`while(nums[mid] > target)`时，`nums[mid]`不是target，但由于区间右端点必须是开区间，因此`right = mid`


```cpp

int search(vector<int>& nums, int target) 
{
	int left = 0, right = nums.size();
	while (left < right)
	{
		int mid = right + (left - right) >> 1;
		if (nums[mid] > target)//target落在区间[left,mid)当中，由于右端点不在检测数组内
		                       //因此right = mid  
		right = mid;
		else if (nums[mid] < target)//target落在区间(mid,right)，由于左端点为闭区间
		                            //因此left = mid + 1
		left = mid + 1;
		else return mid;
	}
		return -1;
}

```

---

**二分查找本质上是对查找区间的不断缩小**，最终一定会变成区间含有三个或者四个元素的情况（区间两端点均为闭区间）。

* 对于前者，下一步的`left`或者`right`将会重合。假设`left=0, right=2`，这时`mid=1`，即与`target`比较的元素为**区间的中点**。那么下一步将会变成`left=0, right=0`，即二者重合，在进行一次判断，这时会产生`left>right`

* 对于后者，假设`left=0, right=3`，这时`mid=1`，即与`target`比较的元素为**中间偏右**。下一步将变成`left=0, right=0`，二者重合，之后的情况与上面一样。


>力扣34
>
>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
>	
>如果数组中不存在目标值 target，返回 [-1, -1]。

```cpp

vector<int> searchRange(vector<int>& nums, int target) 
{
	int n = nums.size();
	int left = Getleft(nums, target);//加一才是下标位置
	int right = Getright(nums, target);//这个是序号位置，下标位置要减一
	if (left == -2 || right == -2) return { -1,-1 };//只要有一个等于-2，说明target一定超界
	else if ((right - 1) - (left + 1) >= 0) return { left + 1,right - 1 };//正常情况，两个数开始与结束相差值大于0（两个数可以相等）
	else return { -1,-1 };//对于这种数组中找不到的情况，想不明白，直接用else
}
private:
int Getright(vector<int>& nums, int target)
{
	int left = 0, right = nums.size() - 1;
	int border = -2;
	while (left <= right)
	{
		int mid = left + (right - left) / 2;
		if (nums[mid] > target)//这里必须是右边界移动，下面的左边界加一才是结果
			right = mid - 1;
		else//相等的话，我们要让左边界向右移动一位
		{
			left = mid + 1;
			border = left;
		}
	}
	return border;
}
int Getleft(vector<int>nums, int target)
{
	int left = 0, right = nums.size() - 1;
	int border = -2;
	while (left <= right)
	{
		int mid = left + (right - left) / 2;
		if (nums[mid] < target)
			left = mid + 1;
		else
		{
			right = mid - 1;
			border = right;
		}
	}
	return border;
}

```

---


## 左右指针操作数组

如果需要移动（或覆盖）一个数组当中的元素，我们可以采取双指针来操作这个数组。左指针为待覆盖元素，右指针为被检测元素（即该元素是否应该去覆盖左指针所指的元素）。

左右指针可同向行进，也可相向行进。


>力扣（26）
>
>给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。
>
>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。
>
>将最终结果插入 nums 的前 k 个位置后返回 k 。
>
>不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

```cpp

int removeDuplicates(vector<int>& nums) 
{
	int left = 0;
	for (int right = 1; right < nums.size(); right++)
	{
		if (nums[right] != nums[left])
		{
			nums[++left] = nums[right];
		}
	}
    return left + 1;
}

```


>字符串的遍历（对于string类）



	for(char c : str)//相当于用c对str进行遍历

	for(char &c : str)//同上，不过上面会将str复制一次，这个不用

>二维数组的初始化

	vector<vector<int>> ret(n, vector<int>(n, 0))

---

## 滑动窗口、左右指针

>力扣209
>
>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并
>
>返回其长度。如果不存在符合条件的子数组，返回 0。


我们定义两个指针，通过不断移动两个指针来得到最优解的过程称之为滑动窗口

需要明确的是：

* 窗口内的内容是什么

* 窗口的右边界确定什么，以及什么时候移动

* 窗口的左边界确定什么，以及什么时候移动

>对于这道题，**窗口的右边界就是遍历数组的指针，它用来一直寻找最优解，需要一直移动**，窗口内容是**一个和大于`target`的子序列**，左边界指针**用来确定当前最优解，即当窗口内容符合条件时，左指针移动**


>三数之和
>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组


```cpp
vector<vector<int>> threeSum(vector<int>& nums)
{
    vector<vector<int>>ret;
    sort(nums.begin(), nums.end());
    for (int i = 0; i < nums.size(); i++)
    {
        if (nums[i] > 0)
            return ret;
        if (i > 0 && nums[i] == nums[i - 1])
            continue;
        int left = i + 1, right = nums.size() - 1;
        while (left < right)
        {
            if (nums[i] + nums[left] + nums[right] > 0)
            {
                right--;
                while (left < right && nums[right] == nums[right + 1])
                    right--;
            }
            else if (nums[i] + nums[left] + nums[right] < 0)
            {
                left++;
                while (left < right && nums[left] == nums[left - 1])
                    left++;
            }
            else
            {
                ret.push_back({ nums[i], nums[left], nums[right] });
                while (left < right && nums[left] == nums[left + 1])
                    left++;
                while (left < right && nums[right] == nums[right - 1])
                    right--;
                left++;
                right--;
            }
        }
    }
    return ret;
}
```
注：由于用的是`if elseif else`语句，在条件成立后**只会走一条路**，因此前面两个的去重是为了保证**找到下一个不同于当前重复数子的数**
第三个的去重是为了保证**在当前重复的数子中，现在的`right`指向的是重复区间的最后一个数字**

>在判断`nums[i] + nums[left] + nums[right] > 0`之后的去重部分为什么是`nums[right] == nums[right + 1]`

对于循环，当**条件不满足的时候才会跳出**，因此跳出之后的情况就是**不满足循环判断部分的条件**。
当`nums[i] + nums[left] + nums[right] > 0`判断完之后，我需要让`right`**跳到下一位**（**不同于**上一位）
因此**在结束循环后**，我需要的状况为`nums[right] ！= nums[right + 1]`



```cpp

int minSubArrayLen(int target, vector<int>& nums)
{
	int sum = 0;//记录大小
	int length = 0;//记录当前长度
	int ret = INT32_MAX;//目前已记录的最短长度
	int left = 0;//左指针初始化
	for (int right = 0; right < nums.size(); right++)
	{
		sum += nums[right];//不需要对sum进行初始化
		while (sum >= target)
		{
			length = right - left + 1;
			ret = ret < length ? ret : length;
			sum -= nums[left++];//sum减去left的值并且left向右移动
		}
	}
	return ret == INT32_MAX ? 0 : ret;
}

```

在使用左右指针的时候我们需要明确左指针与右指针**什么时候需要移动**，以及我需要**通过这两个指针来操作什么**

* 如果我是想要移动数组，那么就右指针赋值给左指针（相当于**删除**元素）或者左指针赋值给右指针（相当于**扩充**元素）

* 如果我想删除链表当中的某个元素（不是特定值，而是正数第几个倒数第几个），我可以先让右指针**向右移动一段距离**，然后再让左右指针**同时**移动，当右指针移动到链表结尾时左指针恰好移动到待删除元素的**节点上**



---


# 链表

由于对链表操作时通常**涉及到该节点的前一个节点，但头节点并没有前一个节点这种概念**，因此我们可以在链表创建时设立一个虚拟头节点`dummyhead`，这个节点不存储数据，第一个存储数据的节点为`dummyhead->next`，这么做的好处时在对链表进行操作时**不需要对头节点进行单独操作**

>关于代码规范上：需要加入的节点写为`NewNode`，临时指针为`tmp`，遍历指针为`cur`

写链表的算法时一定要明确，我设立虚拟头节点的目的是为了对每个节点的操作是可以**复制**的，即**我对任意一个或多个节点的操作都是相同的**


## 删除倒数第n个节点

>例：给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。


删除倒数第n个节点，这种题是典型的双指针的应用

通常想法是先把链表的总大小给统计出来，然后得出指针`cur`需要移动的步数

其实还有一种更简单的方法：

考虑到，如果我定义两个指针：`fast`与`slow`，我**让两个指针同时运动**，两个指针之间相差一定的步数，只要`fast`指向空的时候`slow`正好指向**待删除节点的前一个节点**，那么我们便可以实现节点的删除
注：**删除一个节点只需要一个指针**

>通过画图我们可以得知，只需要让`fast`指针移动`n+1`步就可以让两个指针同时移动了

```cpp

ListNode* removeNthFromEnd(ListNode* head, int n) 
{
    ListNode* dummyhead = new ListNode;
    dummyhead->next = head;
    ListNode* fast = dummyhead, *slow = dummyhead;
    for(int i = 0; i < n + 1; i++)
        fast = fast->next;
    while(fast)
    {
        fast = fast->next;
        slow = slow->next;
    }
    ListNode* tmp = slow->next;
    slow->next = tmp->next;
    delete tmp;
    return dummyhead->next;
}

```

>使用虚拟头节点在返回的时候可以之间返回`dummyhead->next`，这样子更方便

---

对链表（一个与两个链表均同理）用双指针的时候，我们两个指针可以**同时同地移动**，也可以**同时不同地移动**

对于前者，我们可以让**两个指针在链表的开始节点移动**（数组的话可以在尾部开始移动）

对于后者，我们定义两个指针`fast`与`slow`，**我们让`fast`与`slow`相差一定的节点数**（可以是题目给的数也可以是两个链表的长度差），**之后再让两指针同时移动**

当然，我们也可以定义两个指针`slow`与`fast`，我们让**`fast`一次走两个节点**，**`slow`一次走一个节点**，他们一定会相遇，这种通常用在循环链表上。*见力扣142*

## 链表反转

递归实现

```cpp
ListNode* reverseList(ListNode* head) 
{
    if(head == NULL)
        return NULL;
    if(head->next == NULL)
        return head;
    ListNode* tmp = reverseList(head->next);
    head->next->next = head;
    head->next = NULL;
    return tmp;
    
}
```

>为什么要写`head->next->next = head`

tmp**始终**记录的都是头节点，因此只能是用head->next->next来表示**当前节点**（该节点可以移动），而`head`则表示**当前节点的前一个节点**

>为什么判断`head->next == NULL`之后是返回`head`

我们`tmp`的最终值只能是最后一个节点，由于`tmp = reverseList(head->next)`，因此在`head->next`为空指针的时候我就要返回`head`


双指针实现

```cpp
ListNode* reverseList(ListNode* head) 
{
    if(head == NULL)
        return NULL;
    ListNode* pre = NULL, *cur = head;//cur为当前处理的节点，pre为该节点的前一个节点
    while(cur)//我对某个节点处理，只能是对这个节点进行判断
    {
        ListNode* tmp = cur->next;
        cur->next = pre;
        pre = cur;
        cur = tmp;
    }
    return pre;
}
```

双指针递归实现
```cpp

ListNode* reverseList(ListNode* head)
{
	return reverse(NULL, head);
}

ListNode* reverse(ListNode* pre, ListNode* cur)
{
	if(cur == NULL)
		return pre;
	ListNode* tmp = cur->next;
	cur->next = pre;
	return reverse(cur, tmp);
}

```

>为什么在判断`cur == NULL`之后返回的是`pre`

由于`pre`总表示`cur`的前一个节点，因此当`cur`为`NULL`时，说明`pre`已经到达最后一个节点，由于需要直接返回最后一个节点，因此我需要返回`pre`



---

# 哈希表

哈希表是一种用于查询的工具，具体来说，我将数据录入哈希表当中，每个数据对应一个索引key值，在我需要判断某个元素是否存在这个哈希表当中时，我直接去找它的索引就行

**也就是说，当我需要快速判断一个元素是否在一个集合当中时，我就可以考虑用哈希表了**

在引入哈希表前，我们需要先介绍四个容器**（这四个容器均不涉及哈希表）**

>`set`
>>插入容器当中的数据会**自动排序（默认从小到大）**，元素不能更改，并且**不允许相同的元素出现**
>>>相关操作:

	begin()--返回指向第一个元素的迭代器
	
	clear()--清除所有元素
	
	count()--返回某个值元素的个数
	
	empty()--如果集合为空，返回true
	
	end()--返回指向最后一个元素的迭代器
	
	equal_range()--返回集合中与给定值相等的上下限的两个迭代器
	
	erase()--删除集合中的元素
	
	find()--返回一个指向被查找到元素的迭代器
	
	get_allocator()--返回集合的分配器
	
	insert()--在集合中插入元素
	
	lower_bound()--返回指向大于（或等于）某值的第一个元素的迭代器
	
	key_comp()--返回一个用于元素间值比较的函数
	
	max_size()--返回集合能容纳的元素的最大限值
	
	rbegin()--返回指向集合中最后一个元素的反向迭代器
	
	rend()--返回指向集合中第一个元素的反向迭代器
	
	size()--集合中元素的数目
	
	swap()--交换两个集合变量
	
	upper_bound()--返回大于某个值元素的迭代器
	
	value_comp()--返回一个用于比较元素间的值的函数


>`mutilset`跟`set`一样，只不过`mutilset`**允许相同的元素**

---

>`map`容器当中的每一个元素均为一个**对组**，即每个元素成对出现
>>
>>`map`容器当中，对组的`first`为索引`key`值，`second`为`value`值
>>
>>`map`会**按照`key`值来对元素进行排序**，并且`map`**不允许有相同的`key`值出现**
>>
>>`map`只检测`key`值是否相同，它允许有相同的`value`值
>>
>>`map`当中的`value`值是可以更改的，`set`当中的不行
>>>相关操作

	begin()         返回指向map头部的迭代器

     clear(）        删除所有元素

     count()         返回指定元素出现的次数

     empty()         如果map为空则返回true

     end()           返回指向map末尾的迭代器

     equal_range()   返回特殊条目的迭代器对

     erase()         删除一个元素(按照key值删除而不是按照value值删除)

     find()          查找一个元素（按照key值查找，返回迭代器）

     get_allocator() 返回map的配置器

     insert()        插入元素

     key_comp()      返回比较元素key的函数

     lower_bound()   返回键值>=给定元素的第一个位置

     max_size()      返回可以容纳的最大元素个数

     rbegin()        返回一个指向map尾部的逆向迭代器

     rend()          返回一个指向map头部的逆向迭代器

     size()          返回map中元素的个数

     swap()           交换两个map

     upper_bound()    返回键值>给定元素的第一个位置

     value_comp()     返回比较元素value的函数


好了，下面我们引入两个容器，其底层实现为哈希表

>`unordered_set`跟`set`一样，不过它的元素是无序的，并且不允许相同元素出现，相关操作跟`set`一样
>
>`unordered_set`**不允许`value`值被修改**
>
>`unordered_map`跟`map`一样，不过不会按照`key`值进行排序
>
>`unordered_map`的查找是根据`key`值进行查找的，而不是根据`value`值进行查找
>
>`unordered_map`支持用中括号来访问`value`值，如果该`key`值对应的`value`值不存在，那么它会自动创建一个`value`值**并赋值为0**，并且`value`值是可以被修改的


在实际解题当中，由于`unordered_set`与`unordered_map`都是哈希表，但前者仅仅只是具备查询功能，后者可以实现**对元素出现次数的记录**，因此，**如果不需要对元素出现次数进行考虑时，我们一般选择前者**

不管是用哈希表还是二分查找，我们都需要**知道一个确定的元素才可以进行查找**

注：`vector`的删除是**按照元素删除**，`map`与`set`是**按照`key`值删除**

---



## 总结

其实数组也是一种简易的哈希表，当我们在处理字符串的时候，如果**都是小写字符**或**都是大写字符**，那么我们就可以用数组来解（对于每个字符，直接减去字符a或A就可以直接得到对应下标），至于为什么不用`map`或者`set`，因为这两个底层都是红黑树，十分耗时（这种的话可以不用`unordered_set`与`unordered_map`）
>对应题目：力扣242、383

如果题目中**没有限制数组的大小**，那么这个时候就不能用数组（虽然`vector`具有自动扩容的功能，**但这个数组本质上我是想把它当成哈希表一样对待**，因此**我需要用到数组的下标以及下标对应的元素**，而一旦涉及到使用数组的下标，我就必须要对这个数组进行初始化，**对于大小不确定的数组，我无法对其初始化**）

除此之外还有一点，数组是连续的空间，一旦哈希值跨度很大（即数组下标跨度很大），就会造成浪费空间

>对应题目：力扣349

`set`与`map`、`mutilset`与`mutilmap`、`unordered_set`与`unordered_map`均可以做哈希表，分`set`与`map`来说（因为`unordered_set`与`unordered_map`均可以看成`set`与`map`的无序版本）

对于`set`而言，它是集合，只有`key`值的概念，并且它的`key`值是有序的。如果我**仅仅需要看一个数是否在数组当中时**，我便可以用`set`
>对应题目：力扣349、202

对于`map`而言，它有`key`值与`value`值的概念，并且它是按`key`值进行排序的。如果涉及到**一个数字出现的次数等需要记录两个数据的情况**，`set`便不再适用

用`map`的话一般是用`key`值表示**数组元素**，用`value`值表示**数组下标**，在这种情况下，如果不要求数组元素有序的话可以选用`unordered_map`（因为`map`与`mutilmap`均会对`key`值进行排序）

# 字符串

字符串跟数组是一样的，`vector<char>`跟`string`并没有区别，只不过`string`类增加了很多对字符的操作

正因为字符串跟数组一样的特性，因此需要删除数组当中**特定元素**的话可以直接用**双指针**

>力扣27

>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
>
>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。
>
>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。


下面给出我的思路：

>一个最直接的想法是直接一层循环，当我找到特定元素之后再在里面套一层循环来更新数组（把**后面的数字**往前面移动，不过这**一层循环需要把整个数组遍历一遍**）。当内层循环结束之后，外层指针加一，不断循环这一过程。

可以看到，这里增加时间复杂度的主要原因是**只要数组当中出现了特定值，我就需要把数组的后面部分整个往前移动**。也就是说我们移动的是后面的整个部分，即从**出现特定值**之后就要开始移动了。而两层循环实际上就是两个指针，在没有出现特定值的时候，两个指针同时移动。如果一旦出现特定值，我们让内层指针跳过这个特定值之后不断地对外层指针进行赋值，这样便实现了数组的移动。处于统一操作的需要，我们让两个指针同时移动的时候也直接赋值。

```cpp
	class Solution {
	public:
    int removeElement(vector<int>& nums, int val) 
	{
		int left = 0;
		for (int right = 0; right < nums.size(); right++)
		{
			if (nums[right] != val)
				nums[left++] = nums[right];
		}
		return left;
	}
	};
```

## KMP

```cpp

class Solution {
public:
    int strStr(string haystack, string needle)
    {
        if (needle.size() == 0)
            return 0;
        int next[10000] = { 0 };
        GetNext(next, needle);
        int j = 0;
        for (int i = 0; i < haystack.size(); i++)
        {
            while (j > 0 && needle[j] != haystack[i])
                j = next[j - 1];
            if (needle[j] == haystack[i])
                j++;
            if (j == needle.size())
                return i - needle.size() + 1;
        }
        return -1;
    }

    void GetNext(int* next, string& s)
    {
        int j = 0;
        next[0] = j;
        for (int i = 1; i < s.size(); i++)//j表示前缀字符串的末尾，i表示后缀字符串的末尾
        {
            while (j > 0 && s[j] != s[i])
                j = next[j - 1];//j跳到j前面(不包括j)的字符串中最大相同前后缀的值所对应的字符处，相当于减小前缀的长度
                                //为什么是按照next数组的值来进行跳动?
                                //由于next数组里面的值均为该字符之前(包括该字符)的字符串当中最大相同前后缀的值，这样我便可以直接跳过
                                //重复段(前后缀相同)
            if (s[j] == s[i])
                j++;
            next[i] = j;//将前缀长度赋给i, j+1表示前缀长度
        }

    }
};

```

# 栈与队列

## 概述

在进入栈与队列前，我们需要先回答四个问题

1. C++中的stack是容器吗

2. 我们使用的stack是属于哪个版本的STL

3. 我们使用的STL中的stack是如何实现的

4. stack提供迭代器来遍历stack空间吗


首先我们先介绍三个最普遍的STL版本

1. HP STL 其他版本的C++ STL，一般是以HP STL为蓝本实现出来的，HP STL是C++ STL的第一个实现版本，而且开放源代码。

2. P.J.Plauger STL 由P.J.Plauger参照HP STL实现出来的，被Visual C++编译器所采用，不是开源的。

3. SGI STL 由Silicon Graphics Computer Systems公司参照HP STL实现，被Linux的C++编译器GCC所采用，SGI STL是开源软件，源码可读性甚高。


我们先讨论栈

栈是先进后出，即它提供`push`和`pop`接口来实现对元素的操作，**所有的元素都必须满足此性质**，因此栈不提供随机访问的功能，也不提供迭代器

其次，**栈是以底层容器完成其所有的工作，对外统一提供接口，底层容器是可以替换的（也就是说我们可以选择使用哪种容器来实现栈的功能）**

基于此，STL中的栈往往不被归类为容器，而是`container adapter`（容器适配器）

那么问题是，STL中的栈的底层实现是用什么容器

实际上，栈的底层实现可以是`vector`、`deque`、`list`，主要是数组与链表

我们常用的SGI STL，如果没有指定底层实现的话默认是用`deque`为底层结构

当然，我们也可以指定其底层实现为`vector`

```cpp
std::stack<int, vector<int> >s;
```

STL中的`list`与`stack`一样，默认是用`deque`来实现队列功能，指定其底层实现也跟`stack`一样

## string与vector跟stack的联系

+ `string`跟`vector`一样，都支持`push_back`与`pop_back`的操作

+ `push_back`与`pop_back`分别是尾插和尾删，即我们可以认为`vector`是一个**支持随机访问的栈**，**栈顶元素为最后一个元素**


## 单调队列

我们定义这样一个队列：**队列内的元素一定单调增或单调减**，这样的队列称之为单调队列

单调队列的底层容器我们默认用`deque`容器来实现

值得注意的是，单调队列中不一定`push`就不能删除队列中的元素，`pop`就不能增加队列当中的元素。即`push`和`pop`函数的定义可以是

```cpp
void push(int val);

void pop(int val);
```

`push`表示添加值为`val`的元素，`pop`表示删除值为`val`的容器

由于单调队列的实现各不相同，因此这里我们给出一种具体实现

```cpp
    class humdrumqueue
    {
    public:
        deque<int>deq;
        void pop(int value)
        {
            if (!deq.empty() && deq.front() == value)
                deq.pop_front();
        }

        void push(int value)
        {
            while (!deq.empty() && deq.back() < value)
                deq.pop_back();
            deq.push_back(value);
        }

        int front()
        {
            return deq.front();
        }
    };
```

### 关于vector的补充

`vector`中的`insert`和`emplace`都可以插入元素

* `insert`的插入是先将该元素单独生成，然后再复制到指定位置，即会调用该对象的**构造函数**和**拷贝构造函数**

* `emplace`是直接在指定位置生成该元素，只调用**构造函数**

因此`emplace`的速度快于`insert`

`push_back`同理


# 二叉树

## 递归的写法

二叉树经常会涉及到递归的问题，在这里我们详细总结一下递归的写法

+ **确定递归函数的参数与返回值**。我们需要知道在递归中哪些**参数是需要不断改变的**，那么就将这些参数放到递归函数里面。同理，我们需要明确每次**递归的返回值**是什么进而确定**递归函数的返回值**（递归的返回值与递归函数的返回值并不相同）

+ **确定终止条件**

+ **确定单层递归的逻辑**。这里的单层递归指的是递归函数每次重复使用的部分

## 二叉树的翻转问题

>给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点

这道题我们既可以用递归，也可以用迭代

递归的话只支持**先序和后序**

```cpp
TreeNode* invertTree(TreeNode* root) 
{
    if (root == NULL) return root;
    swap(root->left, root->right);  // 中
    invertTree(root->left);         // 左
    invertTree(root->right);        // 右
    return root;
}
```

迭代的话我们用统一迭代法，**前中后三种都可以**

```cpp
TreeNode* invertTree(TreeNode* root) 
{
    stack<TreeNode*> st;
    if (root != NULL) st.push(root);
    while (!st.empty()) {
        TreeNode* node = st.top();
        if (node != NULL) {
            st.pop();
            if (node->right) st.push(node->right);  // 右
            if (node->left) st.push(node->left);    // 左
            st.push(node);                          // 中
            st.push(NULL);
        } else {
            st.pop();
            node = st.top();
            st.pop();
            swap(node->left, node->right);          // 节点处理逻辑
        }
    }
    return root;
}
```

相应地，我们也可以用层次遍历来实现，原理跟迭代相同

>为什么前中后三种顺序均可以

迭代的是用栈来实现的，那么在不考虑将元素出栈的条件下，我将所有的节点全部压入栈中，然后挨个交换它们的左右孩子。我们发现，这个过程是不涉及**节点之间的先后顺序的**，因此前中后三种顺序都可以


>为什么不能用中序递归

上面递归调用中对应的中序遍历的代码为：

```cpp
TreeNode* invertTree(TreeNode* root) 
{
    if (root == NULL) return root;

    invertTree(root->left);         // 左
    swap(root->left, root->right);  // 中
    invertTree(root->right);        // 右
    return root;
}
```

不难发现，我会先遍历某个节点的**左指针**，此时**左指针指向左孩子**。

然后我会交换了该节点的左右孩子，此时 **原先的左指针指向的是右孩子，原先的右指针指向的是左孩子**。

接着，我再去遍历该节点**右指针**，我们会发现此时的**右指针指向的是左孩子**，这里就会导致该节点**右孩子遍历不到的问题**

实际上，我们的代码应该这么写：

```cpp
TreeNode* invertTree(TreeNode* root) 
{
    if (root == NULL) return root;

    invertTree(root->left);         // 左
    swap(root->left, root->right);  // 中
    invertTree(root->left);         // 左
    return root;
}
```

这里要说明一点，我们通常说的遍历左孩子、右孩子只是简单的表述，实际上应该是**通过左指针去遍历左孩子**，**通过右指针去遍历右孩子**

