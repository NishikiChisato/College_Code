#算法性能分析
## 大O的定义

+ 大O的定义指的是一个算法最坏的运行时间的上界，而我们通常说所的时间复杂度为一般情况，并不是严格的上界

+ 由于时间复杂度会忽略常数项，**因此并不是时间复杂度越低越好**
	+ 这是因为大O衡量的是数据量级非常大的情况下所表现出来的时间复杂度，此时常数项已经不起作用
	+ 对于一个复杂的大O表达式，我们只取最高量级的数并且忽略掉它的常数


###一个例子

找出n个字符串中相同的两个字符串（假设这里只有两个相同的字符串）

*通过暴力枚举的话需要O(n^2)，但这里涉及到两个字符串的逐字节比较的问题，因此需要再乘上字符串的长度m，即O(m * n^2)*

*如果我们采取先排序再查找的思路，对于快排而言，由于是字符串排序，时间复杂度为O(m * n * logn)，由于是按照字典序排列的，因此相同的两个字符串是排在一起的，因此只需在在排序的基础上加上遍历n个字符串与比较两个字符串所花的时间即可，因此总时间复杂度为O(m * n * logn + m * n)，比直接暴力枚举要快*

---

##递归算法的时间复杂度分析

+ 递归算法时间复杂度本质上是看`递归的次数 * 每次递归中的操作次数`


例如，我需要求x的n次方

```cpp
int fact(int x, int n)
{
	int temp = 1;
	for (int i = 0; i < n; i++)
		temp *= x;
	return temp;
}
```

我们可以写出该代码的递归代码

```cpp
int fact1(int x, int n)
{
	if (n == 0)
		return 1;
	else
		return fact1(x, n - 1) * n;
}
```

该代码的执行次数为n-1，每一次只执行一次乘法，因此总的时间复杂度为O(n)

```cpp
int fact2(int x, int n)
{
	if (n == 0)
		return 1;
	if (n & 1)//n is odd
		return fact2(x, n / 2) * fact2(x, n / 2) * x;
	else
		return fact2(x, n / 2) * fact2(x, n / 2);
}
```

**满二叉树相关结论**

`
* 二叉树的层数从1开始计算，深度为最大的层数
* 第k层最多有2的k-1次方个节点
* 总节点为n的满二叉数，其深度为logn下取整加1
`

该代码可以看成一个满二叉树，即：

！[满二叉树](https://img-blog.csdnimg.cn/20201209193909426.png)
