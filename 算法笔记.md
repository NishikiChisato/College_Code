## 算法性能分析
## 大O的定义

+ 大O的定义指的是一个算法最坏的运行时间的上界，而我们通常说所的时间复杂度为一般情况，并不是严格的上界

+ 由于时间复杂度会忽略常数项，**因此并不是时间复杂度越低越好**
	+ 这是因为大O衡量的是数据量级非常大的情况下所表现出来的时间复杂度，此时常数项已经不起作用
	+ 对于一个复杂的大O表达式，我们只取最高量级的数并且忽略掉它的常数


### 一个例子

找出n个字符串中相同的两个字符串（假设这里只有两个相同的字符串）

*通过暴力枚举的话需要O(n^2)，但这里涉及到两个字符串的逐字节比较的问题，因此需要再乘上字符串的长度m，即O(m * n^2)*

*如果我们采取先排序再查找的思路，对于快排而言，由于是字符串排序，时间复杂度为O(m * n * logn)，由于是按照字典序排列的，因此相同的两个字符串是排在一起的，因此只需在在排序的基础上加上遍历n个字符串与比较两个字符串所花的时间即可，因此总时间复杂度为O(m * n * logn + m * n)，比直接暴力枚举要快*

---

## 递归算法的时间复杂度分析

+ 递归算法时间复杂度本质上是看`递归的次数 * 每次递归中的操作次数`


例如，我需要求x的n次方


	int fact(int x, int n)
	{
	int temp = 1;
	for (int i = 0; i < n; i++)
		temp *= x;
	return temp;
	}


我们可以写出该代码的递归代码


	int fact1(int x, int n)
	{
	if (n == 0)
		return 1;
	else
		return fact1(x, n - 1) * n;
	}


该代码的执行次数为n-1，每一次只执行一次乘法，因此总的时间复杂度为O(n)


	int fact2(int x, int n)
	{
	if (n == 0)
		return 1;
	if (n & 1)//n is odd
		return fact2(x, n / 2) * fact2(x, n / 2) * x;
	else
		return fact2(x, n / 2) * fact2(x, n / 2);
	}

---


**满二叉树相关结论**

`
* 二叉树的层数从1开始计算，深度为最大的层数
* 第k层最多有2的k-1次方个节点
* 总节点为n的满二叉数，其深度为logn下取整加1
* 若满二叉树的深度为h，则其总结点个数为2的h次方减1
`

该代码可以看成一个满二叉树，即：

![满二叉树](https://img-blog.csdnimg.cn/20201209193909426.png)

设x为总节点个数，h为满二叉树的深度，有`x = 2^h - 1, h = log 2 n + 1`
带入得到`x = 2n - 1`因此时间复杂度为O(n)

上面的递归中`fact2`算了两次，其实我们可以用一个变量记录它的值，然后让该变量自乘一次便可

	int fact3(int x, int n)	
	{
	if (n == 0)
		return 1;
	int temp = fact3(x, n / 2);
	if (n & 1)//n is odd
		return temp * temp * x;
	else
		return temp * temp;
	}


这里的递归次数为`O(logn)`，每一次递归乘法的运算为`O(2)`，因此总的时间复杂度为`O(logn)`

---


# 数组

## 二分查找的写法

二分查找有两种区间写法，左闭右闭与左闭右开。对于循环部分的判断以及mid的跳转一定要按照区间来写

### 左闭右闭

左闭右闭说明了**区间的左右端点都在数组当中有数值对应**，即左端点对应第一个数，右端点对应最后一个数

* 对于循环部分，应写`while(left <= right)`。这是因为当`left = right`时，区间依旧有意义（它是一个点）

* 对于mid的跳转部分，应写`left = mid + 1`。这是因为如果`while(nums[mid] < target)`时，说明`nums[mid]`一定不是target，并且不需要再去检测`nums[mid]`，即区间的左端点直接跳到`mid + 1`就行

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) 
    {
        int left = 0, right = nums.size() - 1;//闭区间[left,right]写法，nums[right]为数组最后一个元素
        while (left <= right)//对于区间[left,right]而言，区间左端点left与右端点right重合依旧有意义
        {
            int mid = right + (left - right) >> 1;//直接用加号会溢出
            if (nums[mid] > target)//nums[mid]一定不是target，表明target在[left,mid-1]当中
                right = mid - 1;
            else if (nums[mid] < target)//nums[mid]一定不是target，target落在[mid+1,right]中
                left = mid + 1;
            else return mid;
        }
        return -1;//循环结束，说明没有找到，直接返回-1
    }
};
```

### 左闭右开

左闭右开说明**区间的右端点不是数组最后一个元素，而是最后一个元素的下一个**，即`右端点-1`才是数组当中最后一个元素

* 对于循环部分，写`while(left < right)`。因为当`left = right`时，区间无意义

* 对于区间左端点的跳转部分，当`while(nums[mid] < target)`时，`nums[mid]`不是target，由于区间是**左闭**的属性，因此`left = mid + 1`

* 对于区间右端点的跳转部分，当`while(nums[mid] > target)`时，`nums[mid]`不是target，但由于区间右端点必须是开区间，因此`right = mid`


```cpp
	class Solution {
	public:
	int search(vector<int>& nums, int target) 
	{
		int left = 0, right = nums.size();
		while (left < right)
		{
			int mid = right + (left - right) >> 1;
			if (nums[mid] > target)//target落在区间[left,mid)当中，由于右端点不在检测数组内
			                       //因此right = mid  
			right = mid;
			else if (nums[mid] < target)//target落在区间(mid,right)，由于左端点为闭区间
			                            //因此left = mid + 1
			left = mid + 1;
			else return mid;
		}
			return -1;
	}
	};
```

---

**二分查找本质上是对查找区间的不断缩小**，最终一定会变成区间含有三个或者四个元素的情况（区间两端点均为闭区间）。

* 对于前者，下一步的`left`或者`right`将会重合。假设`left=0, right=2`，这时`mid=1`，即与`target`比较的元素为**区间的中点**。那么下一步将会变成`left=0, right=0`，即二者重合，在进行一次判断，这时会产生`left>right`

* 对于后者，假设`left=0, right=3`，这时`mid=1`，即与`target`比较的元素为**中间偏右**。下一步将变成`left=0, right=0`，二者重合，之后的情况与上面一样。


>力扣34
>
>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
>	
>如果数组中不存在目标值 target，返回 [-1, -1]。


	class Solution {
	public:
    vector<int> searchRange(vector<int>& nums, int target) 
	{
		int n = nums.size();
		int left = Getleft(nums, target);//加一才是下标位置
		int right = Getright(nums, target);//这个是序号位置，下标位置要减一
		if (left == -2 || right == -2) return { -1,-1 };//只要有一个等于-2，说明target一定超界
		else if ((right - 1) - (left + 1) >= 0) return { left + 1,right - 1 };//正常情况，两个数开始与结束相差值大于0（两个数可以相等）
		else return { -1,-1 };//对于这种数组中找不到的情况，想不明白，直接用else
	}
	private:
	int Getright(vector<int>& nums, int target)
	{
		int left = 0, right = nums.size() - 1;
		int border = -2;
		while (left <= right)
		{
			int mid = left + (right - left) / 2;
			if (nums[mid] > target)//这里必须是右边界移动，下面的左边界加一才是结果
				right = mid - 1;
			else//相等的话，我们要让左边界向右移动一位
			{
				left = mid + 1;
				border = left;
			}
		}
		return border;
	}
	int Getleft(vector<int>nums, int target)
	{
		int left = 0, right = nums.size() - 1;
		int border = -2;
		while (left <= right)
		{
			int mid = left + (right - left) / 2;
			if (nums[mid] < target)
				left = mid + 1;
			else
			{
				right = mid - 1;
				border = right;
			}
		}
		return border;
	}
	};

---


## 左右指针操作数组

如果需要移动（或覆盖）一个数组当中的元素，我们可以采取双指针来操作这个数组。左指针为待覆盖元素，右指针为被检测元素（即该元素是否应该去覆盖左指针所指的元素）。

左右指针可同向行进，也可相向行进。


>力扣（26）
>
>给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。
>
>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。
>
>将最终结果插入 nums 的前 k 个位置后返回 k 。
>
>不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。


	class Solution {
	public:
    int removeDuplicates(vector<int>& nums) 
	{
		int left = 0;
		for (int right = 1; right < nums.size(); right++)
		{
			if (nums[right] != nums[left])
			{
				nums[++left] = nums[right];
			}
		}
        return left + 1;
	}
	};



>字符串的遍历（对于string类）



	for(char c : str)//相当于用c对str进行遍历

	for(char &c : str)//同上，不过上面会将str复制一次，这个不用

>二维数组的初始化

	vector<vector<int>> ret(n, vector<int>(n, 0))

---

## 滑动窗口、左右指针

>力扣209
>
>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并
>
>返回其长度。如果不存在符合条件的子数组，返回 0。


我们定义两个指针，通过不断移动两个指针来得到最优解的过程称之为滑动窗口

需要明确的是：

* 窗口内的内容是什么

* 窗口的右边界确定什么，以及什么时候移动

* 窗口的左边界确定什么，以及什么时候移动

>对于这道题，**窗口的右边界就是遍历数组的指针，它用来一直寻找最优解，需要一直移动**，窗口内容是**一个和大于`target`的子序列**，左边界指针**用来确定当前最优解，即当窗口内容符合条件时，左指针移动**


	class Solution {
	public:
    int minSubArrayLen(int target, vector<int>& nums)
	{
		int sum = 0;//记录大小
		int length = 0;//记录当前长度
		int ret = INT32_MAX;//目前已记录的最短长度
		int left = 0;//左指针初始化
		for (int right = 0; right < nums.size(); right++)
		{
			sum += nums[right];//不需要对sum进行初始化
			while (sum >= target)
			{
				length = right - left + 1;
				ret = ret < length ? ret : length;
				sum -= nums[left++];//sum减去left的值并且left向右移动
			}
		}
		return ret == INT32_MAX ? 0 : ret;
	}
	};

在使用左右指针的时候我们需要明确左指针与右指针**什么时候需要移动**，以及我需要**通过这两个指针来操作什么**

* 如果我是想要移动数组，那么就右指针赋值给左指针（相当于**删除**元素）或者左指针赋值给右指针（相当于**扩充**元素）

* 如果我想删除链表当中的某个元素（不是特定值，而是正数第几个倒数第几个），我可以先让右指针**向右移动一段距离**，然后再让左右指针**同时**移动，当右指针移动到链表结尾时左指针恰好移动到待删除元素的**节点上**



---


# 链表

由于对链表操作时通常**涉及到该节点的前一个节点，但头节点并没有前一个节点这种概念**，因此我们可以在链表创建时设立一个虚拟头节点`dummyhead`，这个节点不存储数据，第一个存储数据的节点为`dummyhead->next`，这么做的好处时在对链表进行操作时**不需要对头节点进行单独操作**

>关于代码规范上：需要加入的节点写为`NewNode`，临时指针为`tmp`，遍历指针为`cur`

写链表的算法时一定要明确，我设立虚拟头节点的目的是为了对每个节点的操作是可以**复制**的，即**我对任意一个或多个节点的操作都是相同的**


>例：给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。


删除倒数第n个节点，这种题是典型的双指针的应用

通常想法是先把链表的总大小给统计出来，然后得出指针`cur`需要移动的步数

其实还有一种更简单的方法：

考虑到，如果我定义两个指针：`fast`与`slow`，我**让两个指针同时运动**，两个指针之间相差一定的步数，只要`fast`指向空的时候`slow`正好指向**待删除节点的前一个节点**，那么我们便可以实现节点的删除
注：**删除一个节点只需要一个指针**

>通过画图我们可以得知，只需要让`fast`指针移动`n+1`步就可以让两个指针同时移动了

	class Solution {
	public:
    ListNode* removeNthFromEnd(ListNode* head, int n) 
    {
        ListNode* dummyhead = new ListNode;
        dummyhead->next = head;
        ListNode* fast = dummyhead, *slow = dummyhead;
        for(int i = 0; i < n + 1; i++)
            fast = fast->next;
        while(fast)
        {
            fast = fast->next;
            slow = slow->next;
        }
        ListNode* tmp = slow->next;
        slow->next = tmp->next;
        delete tmp;
        return dummyhead->next;
    }
	};

>使用虚拟头节点在返回的时候可以之间返回`dummyhead->next`，这样子更方便

---

对链表（一个与两个链表均同理）用双指针的时候，我们两个指针可以**同时同地移动**，也可以**同时不同地移动**

对于前者，我们可以让**两个指针在链表的开始节点移动**（数组的话可以在尾部开始移动）

对于后者，我们定义两个指针`fast`与`slow`，**我们让`fast`与`slow`相差一定的节点数**（可以是题目给的数也可以是两个链表的长度差），**之后再让两指针同时移动**

当然，我们也可以定义两个指针`slow`与`fast`，我们让**`fast`一次走两个节点**，**`slow`一次走一个节点**，他们一定会相遇，这种通常用在循环链表上。*见力扣142*

---

# 哈希表

哈希表是一种用于查询的工具，具体来说，我将数据录入哈希表当中，每个数据对应一个索引key值，在我需要判断某个元素是否存在这个哈希表当中时，我直接去找它的索引就行

**也就是说，当我需要快速判断一个元素是否在一个集合当中时，我就可以考虑用哈希表了**

在引入哈希表前，我们需要先介绍四个容器**（这四个容器均不涉及哈希表）**

>`set`
>>插入容器当中的数据会**自动排序（默认从小到大）**，元素不能更改，并且**不允许相同的元素出现**
>>>相关操作:

	begin()--返回指向第一个元素的迭代器
	
	clear()--清除所有元素
	
	count()--返回某个值元素的个数
	
	empty()--如果集合为空，返回true
	
	end()--返回指向最后一个元素的迭代器
	
	equal_range()--返回集合中与给定值相等的上下限的两个迭代器
	
	erase()--删除集合中的元素
	
	find()--返回一个指向被查找到元素的迭代器
	
	get_allocator()--返回集合的分配器
	
	insert()--在集合中插入元素
	
	lower_bound()--返回指向大于（或等于）某值的第一个元素的迭代器
	
	key_comp()--返回一个用于元素间值比较的函数
	
	max_size()--返回集合能容纳的元素的最大限值
	
	rbegin()--返回指向集合中最后一个元素的反向迭代器
	
	rend()--返回指向集合中第一个元素的反向迭代器
	
	size()--集合中元素的数目
	
	swap()--交换两个集合变量
	
	upper_bound()--返回大于某个值元素的迭代器
	
	value_comp()--返回一个用于比较元素间的值的函数


>`mutilset`跟`set`一样，只不过`mutilset`**允许相同的元素**

---

>`map`容器当中的每一个元素均为一个**对组**，即每个元素成对出现
>>
>>`map`容器当中，对组的`first`为索引`key`值，`second`为`value`值
>>
>>`map`会**按照`key`值来对元素进行排序**，并且`map`**不允许有相同的`key`值出现**
>>
>>`map`只检测`key`值是否相同，它允许有相同的`value`值
>>
>>`map`当中的`value`值是可以更改的，`set`当中的不行
>>>相关操作

	begin()         返回指向map头部的迭代器

     clear(）        删除所有元素

     count()         返回指定元素出现的次数

     empty()         如果map为空则返回true

     end()           返回指向map末尾的迭代器

     equal_range()   返回特殊条目的迭代器对

     erase()         删除一个元素(按照key值删除而不是按照value值删除)

     find()          查找一个元素（按照key值查找，返回迭代器）

     get_allocator() 返回map的配置器

     insert()        插入元素

     key_comp()      返回比较元素key的函数

     lower_bound()   返回键值>=给定元素的第一个位置

     max_size()      返回可以容纳的最大元素个数

     rbegin()        返回一个指向map尾部的逆向迭代器

     rend()          返回一个指向map头部的逆向迭代器

     size()          返回map中元素的个数

     swap()           交换两个map

     upper_bound()    返回键值>给定元素的第一个位置

     value_comp()     返回比较元素value的函数


好了，下面我们引入两个容器，其底层实现为哈希表

>`unordered_set`跟`set`一样，不过它的元素是无序的，并且不允许相同元素出现，相关操作跟`set`一样
>
>`unordered_set`**不允许`value`值被修改**
>
>`unordered_map`跟`map`一样，不过不会按照`key`值进行排序
>
>`unordered_map`的查找是根据`key`值进行查找的，而不是根据`value`值进行查找
>
>`unordered_map`支持用中括号来访问`value`值，如果该`key`值对应的`value`值不存在，那么它会自动创建一个`value`值**并赋值为0**，并且`value`值是可以被修改的


在实际解题当中，由于`unordered_set`与`unordered_map`都是哈希表，但前者仅仅只是具备查询功能，后者可以实现**对元素出现次数的记录**，因此，**如果不需要对元素出现次数进行考虑时，我们一般选择前者**

不管是用哈希表还是二分查找，我们都需要**知道一个确定的元素才可以进行查找**

注：`vector`的删除是**按照元素删除**，`map`与`set`是**按照`key`值删除**

---



## 总结

其实数组也是一种简易的哈希表，当我们在处理字符串的时候，如果**都是小写字符**或**都是大写字符**，那么我们就可以用数组来解（对于每个字符，直接减去字符a或A就可以直接得到对应下标），至于为什么不用`map`或者`set`，因为这两个底层都是红黑树，十分耗时（这种的话可以不用`unordered_set`与`unordered_map`）
>对应题目：力扣242、383

如果题目中**没有限制数组的大小**，那么这个时候就不能用数组（虽然`vector`具有自动扩容的功能，**但这个数组本质上我是想把它当成哈希表一样对待**，因此**我需要用到数组的下标以及下标对应的元素**，而一旦涉及到使用数组的下标，我就必须要对这个数组进行初始化，**对于大小不确定的数组，我无法对其初始化**）

除此之外还有一点，数组是连续的空间，一旦哈希值跨度很大（即数组下标跨度很大），就会造成浪费空间

>对应题目：力扣349

`set`与`map`、`mutilset`与`mutilmap`、`unordered_set`与`unordered_map`均可以做哈希表，分`set`与`map`来说（因为`unordered_set`与`unordered_map`均可以看成`set`与`map`的无序版本）

对于`set`而言，它是集合，只有`key`值的概念，并且它的`key`值是有序的。如果我**仅仅需要看一个数是否在数组当中时**，我便可以用`set`
>对应题目：力扣349、202

对于`map`而言，它有`key`值与`value`值的概念，并且它是按`key`值进行排序的。如果涉及到**一个数字出现的次数等需要记录两个数据的情况**，`set`便不再适用

用`map`的话一般是用`key`值表示**数组元素**，用`value`值表示**数组下标**，在这种情况下，如果不要求数组元素有序的话可以选用`unordered_map`（因为`map`与`mutilmap`均会对`key`值进行排序）

# 字符串

字符串跟数组是一样的，`vector<char>`跟`string`并没有区别，只不过`string`类增加了很多对字符的操作

正因为字符串跟数组一样的特性，因此需要删除数组当中**特定元素**的话可以直接用**双指针**

>力扣27

>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
>
>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。
>
>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。


下面给出我的思路：

>一个最直接的想法是直接一层循环，当我找到特定元素之后再在里面套一层循环来更新数组（把**后面的数字**往前面移动，不过这**一层循环需要把整个数组遍历一遍**）。当内层循环结束之后，外层指针加一，不断循环这一过程。

可以看到，这里增加时间复杂度的主要原因是**只要数组当中出现了特定值，我就需要把数组的后面部分整个往前移动**。也就是说我们移动的是后面的整个部分，即从**出现特定值**之后就要开始移动了。而两层循环实际上就是两个指针，在没有出现特定值的时候，两个指针同时移动。如果一旦出现特定值，我们让内层指针跳过这个特定值之后不断地对外层指针进行赋值，这样便实现了数组的移动。处于统一操作的需要，我们让两个指针同时移动的时候也直接赋值。

	class Solution {
	public:
    int removeElement(vector<int>& nums, int val) 
	{
		int left = 0;
		for (int right = 0; right < nums.size(); right++)
		{
			if (nums[right] != val)
				nums[left++] = nums[right];
		}
		return left;
	}
	};
