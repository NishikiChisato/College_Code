## 算法性能分析
### 大O的定义

+ 大O的定义指的是一个算法最坏的运行时间的上界，而我们通常说所的时间复杂度为一般情况，并不是严格的上界

+ 由于时间复杂度会忽略常数项，**因此并不是时间复杂度越低越好**
	+ 这是因为大O衡量的是数据量级非常大的情况下所表现出来的时间复杂度，此时常数项已经不起作用
	+ 对于一个复杂的大O表达式，我们只取最高量级的数并且忽略掉它的常数


#### 一个例子

找出n个字符串中相同的两个字符串（假设这里只有两个相同的字符串）

* 通过暴力枚举的话需要O(n^2)，但这里涉及到两个字符串的逐字节比较的问题，因此需要再乘上字符串的长度m，即O(m * n^2)

* 如果我们采取先排序再查找的思路，对于快排而言，由于是字符串排序，时间复杂度为O(m * n * logn)，由于是按照字典序排列的，因此相同的两个字符串是排在一起的，因此只需在在排序的基础上加上遍历n个字符串与比较两个字符串所花的时间即可，因此总时间复杂度为O(m * n * logn + m * n)，比直接暴力枚举要快

---

##递归算法的时间复杂度分析

+ 递归算法时间复杂度本质上是看`递归的次数 * 每次递归中的操作次数`


例如，我需要求x的n次方


```cpp
int fact(int x, int n)
{
int temp = 1;
for (int i = 0; i < n; i++)
	temp *= x;
return temp;
}
```


我们可以写出该代码的递归代码


```cpp
int fact1(int x, int n)
{
if (n == 0)
	return 1;
else
	return fact1(x, n - 1) * n;
}
```


该代码的执行次数为n-1，每一次只执行一次乘法，因此总的时间复杂度为O(n)

```cpp
int fact2(int x, int n)
{
if (n == 0)
	return 1;
if (n & 1)//n is odd
	return fact2(x, n / 2) * fact2(x, n / 2) * x;
else
	return fact2(x, n / 2) * fact2(x, n / 2);
}
```

---


**满二叉树相关结论**

`
* 二叉树的层数从1开始计算，深度为最大的层数
* 第k层最多有2的k-1次方个节点
* 总节点为n的满二叉数，其深度为logn下取整加1
* 若满二叉树的深度为h，则其总结点个数为2的h次方减1
`

该代码可以看成一个满二叉树，即：

![满二叉树](https://img-blog.csdnimg.cn/20201209193909426.png)

设x为总节点个数，h为满二叉树的深度，有`x = 2^h - 1, h = log 2 n + 1`
带入得到`x = 2n - 1`因此时间复杂度为O(n)

上面的递归中`fact2`算了两次，其实我们可以用一个变量记录它的值，然后让该变量自乘一次便可

```cpp
int fact3(int x, int n)	
{
if (n == 0)
	return 1;
int temp = fact3(x, n / 2);
if (n & 1)//n is odd
	return temp * temp * x;
else
	return temp * temp;
}
```


这里的递归次数为`O(logn)`，每一次递归乘法的运算为`O(2)`，因此总的时间复杂度为`O(logn)`

---


# 数组

## 二分查找的写法

二分查找有两种区间写法，左闭右闭与左闭右开。对于循环部分的判断以及mid的跳转一定要按照区间来写

### 左闭右闭

左闭右闭说明了**区间的左右端点都在数组当中有数值对应**，即左端点对应第一个数，右端点对应最后一个数

* 对于循环部分，应写`while(left <= right)`。这是因为当`left = right`时，区间依旧有意义（它是一个点）

* 对于mid的跳转部分，应写`left = mid + 1`。这是因为如果`while(nums[mid] < target)`时，说明`nums[mid]`一定不是target，并且不需要再去检测`nums[mid]`，即区间的左端点直接跳到`mid + 1`就行

```cpp

int search(vector<int>& nums, int target) 
{
    int left = 0, right = nums.size() - 1;//闭区间[left,right]写法，nums[right]为数组最后一个元素
    while (left <= right)//对于区间[left,right]而言，区间左端点left与右端点right重合依旧有意义
    {
        int mid = right + (left - right) >> 1;//直接用加号会溢出
        if (nums[mid] > target)//nums[mid]一定不是target，表明target在[left,mid-1]当中
            right = mid - 1;
        else if (nums[mid] < target)//nums[mid]一定不是target，target落在[mid+1,right]中
            left = mid + 1;
        else return mid;
    }
    return -1;//循环结束，说明没有找到，直接返回-1
}

```

### 左闭右开

左闭右开说明**区间的右端点不是数组最后一个元素，而是最后一个元素的下一个**，即`右端点-1`才是数组当中最后一个元素

* 对于循环部分，写`while(left < right)`。因为当`left = right`时，区间无意义

* 对于区间左端点的跳转部分，当`while(nums[mid] < target)`时，`nums[mid]`不是target，由于区间是**左闭**的属性，因此`left = mid + 1`

* 对于区间右端点的跳转部分，当`while(nums[mid] > target)`时，`nums[mid]`不是target，但由于区间右端点必须是开区间，因此`right = mid`


```cpp

int search(vector<int>& nums, int target) 
{
	int left = 0, right = nums.size();
	while (left < right)
	{
		int mid = right + (left - right) >> 1;
		if (nums[mid] > target)//target落在区间[left,mid)当中，由于右端点不在检测数组内
		                       //因此right = mid  
		right = mid;
		else if (nums[mid] < target)//target落在区间(mid,right)，由于左端点为闭区间
		                            //因此left = mid + 1
		left = mid + 1;
		else return mid;
	}
		return -1;
}

```

---

**二分查找本质上是对查找区间的不断缩小**，最终一定会变成区间含有三个或者四个元素的情况（区间两端点均为闭区间）。

* 对于前者，下一步的`left`或者`right`将会重合。假设`left=0, right=2`，这时`mid=1`，即与`target`比较的元素为**区间的中点**。那么下一步将会变成`left=0, right=0`，即二者重合，在进行一次判断，这时会产生`left>right`

* 对于后者，假设`left=0, right=3`，这时`mid=1`，即与`target`比较的元素为**中间偏右**。下一步将变成`left=0, right=0`，二者重合，之后的情况与上面一样。


>力扣34
>
>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
>	
>如果数组中不存在目标值 target，返回 [-1, -1]。

```cpp

vector<int> searchRange(vector<int>& nums, int target) 
{
	int n = nums.size();
	int left = Getleft(nums, target);//加一才是下标位置
	int right = Getright(nums, target);//这个是序号位置，下标位置要减一
	if (left == -2 || right == -2) return { -1,-1 };//只要有一个等于-2，说明target一定超界
	else if ((right - 1) - (left + 1) >= 0) return { left + 1,right - 1 };//正常情况，两个数开始与结束相差值大于0（两个数可以相等）
	else return { -1,-1 };//对于这种数组中找不到的情况，想不明白，直接用else
}
private:
int Getright(vector<int>& nums, int target)
{
	int left = 0, right = nums.size() - 1;
	int border = -2;
	while (left <= right)
	{
		int mid = left + (right - left) / 2;
		if (nums[mid] > target)//这里必须是右边界移动，下面的左边界加一才是结果
			right = mid - 1;
		else//相等的话，我们要让左边界向右移动一位
		{
			left = mid + 1;
			border = left;
		}
	}
	return border;
}
int Getleft(vector<int>nums, int target)
{
	int left = 0, right = nums.size() - 1;
	int border = -2;
	while (left <= right)
	{
		int mid = left + (right - left) / 2;
		if (nums[mid] < target)
			left = mid + 1;
		else
		{
			right = mid - 1;
			border = right;
		}
	}
	return border;
}

```

---


## 左右指针操作数组

如果需要移动（或覆盖）一个数组当中的元素，我们可以采取双指针来操作这个数组。左指针为待覆盖元素，右指针为被检测元素（即该元素是否应该去覆盖左指针所指的元素）。

左右指针可同向行进，也可相向行进。


>力扣（26）
>
>给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。
>
>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。
>
>将最终结果插入 nums 的前 k 个位置后返回 k 。
>
>不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

```cpp

int removeDuplicates(vector<int>& nums) 
{
	int left = 0;
	for (int right = 1; right < nums.size(); right++)
	{
		if (nums[right] != nums[left])
		{
			nums[++left] = nums[right];
		}
	}
    return left + 1;
}

```


>字符串的遍历（对于string类）



```cpp
for(char c : str)//相当于用c对str进行遍历

for(char &c : str)//同上，不过上面会将str复制一次，这个不用
```

>二维数组的初始化

```cpp
vector<vector<int>> ret(n, vector<int>(n, 0))
```

---

## 滑动窗口、左右指针

>力扣209
>
>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并
>
>返回其长度。如果不存在符合条件的子数组，返回 0。


我们定义两个指针，通过不断移动两个指针来得到最优解的过程称之为滑动窗口

需要明确的是：

* 窗口内的内容是什么

* 窗口的右边界确定什么，以及什么时候移动

* 窗口的左边界确定什么，以及什么时候移动

>对于这道题，**窗口的右边界就是遍历数组的指针，它用来一直寻找最优解，需要一直移动**，窗口内容是**一个和大于`target`的子序列**，左边界指针**用来确定当前最优解，即当窗口内容符合条件时，左指针移动**


>三数之和
>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组


```cpp
vector<vector<int>> threeSum(vector<int>& nums)
{
    vector<vector<int>>ret;
    sort(nums.begin(), nums.end());
    for (int i = 0; i < nums.size(); i++)
    {
        if (nums[i] > 0)
            return ret;
        if (i > 0 && nums[i] == nums[i - 1])
            continue;
        int left = i + 1, right = nums.size() - 1;
        while (left < right)
        {
            if (nums[i] + nums[left] + nums[right] > 0)
            {
                right--;
                while (left < right && nums[right] == nums[right + 1])
                    right--;
            }
            else if (nums[i] + nums[left] + nums[right] < 0)
            {
                left++;
                while (left < right && nums[left] == nums[left - 1])
                    left++;
            }
            else
            {
                ret.push_back({ nums[i], nums[left], nums[right] });
                while (left < right && nums[left] == nums[left + 1])
                    left++;
                while (left < right && nums[right] == nums[right - 1])
                    right--;
                left++;
                right--;
            }
        }
    }
    return ret;
}
```
注：由于用的是`if elseif else`语句，在条件成立后**只会走一条路**，因此前面两个的去重是为了保证**找到下一个不同于当前重复数子的数**
第三个的去重是为了保证**在当前重复的数子中，现在的`right`指向的是重复区间的最后一个数字**

>在判断`nums[i] + nums[left] + nums[right] > 0`之后的去重部分为什么是`nums[right] == nums[right + 1]`

对于循环，当**条件不满足的时候才会跳出**，因此跳出之后的情况就是**不满足循环判断部分的条件**。
当`nums[i] + nums[left] + nums[right] > 0`判断完之后，我需要让`right`**跳到下一位**（**不同于**上一位）
因此**在结束循环后**，我需要的状况为`nums[right] ！= nums[right + 1]`



```cpp

int minSubArrayLen(int target, vector<int>& nums)
{
	int sum = 0;//记录大小
	int length = 0;//记录当前长度
	int ret = INT32_MAX;//目前已记录的最短长度
	int left = 0;//左指针初始化
	for (int right = 0; right < nums.size(); right++)
	{
		sum += nums[right];//不需要对sum进行初始化
		while (sum >= target)
		{
			length = right - left + 1;
			ret = ret < length ? ret : length;
			sum -= nums[left++];//sum减去left的值并且left向右移动
		}
	}
	return ret == INT32_MAX ? 0 : ret;
}

```

在使用左右指针的时候我们需要明确左指针与右指针**什么时候需要移动**，以及我需要**通过这两个指针来操作什么**

* 如果我是想要移动数组，那么就右指针赋值给左指针（相当于**删除**元素）或者左指针赋值给右指针（相当于**扩充**元素）

* 如果我想删除链表当中的某个元素（不是特定值，而是正数第几个倒数第几个），我可以先让右指针**向右移动一段距离**，然后再让左右指针**同时**移动，当右指针移动到链表结尾时左指针恰好移动到待删除元素的**节点上**



---


# 链表

由于对链表操作时通常**涉及到该节点的前一个节点，但头节点并没有前一个节点这种概念**，因此我们可以在链表创建时设立一个虚拟头节点`dummyhead`，这个节点不存储数据，第一个存储数据的节点为`dummyhead->next`，这么做的好处时在对链表进行操作时**不需要对头节点进行单独操作**

>关于代码规范上：需要加入的节点写为`NewNode`，临时指针为`tmp`，遍历指针为`cur`

写链表的算法时一定要明确，我设立虚拟头节点的目的是为了对每个节点的操作是可以**复制**的，即**我对任意一个或多个节点的操作都是相同的**


## 删除倒数第n个节点

>例：给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。


删除倒数第n个节点，这种题是典型的双指针的应用

通常想法是先把链表的总大小给统计出来，然后得出指针`cur`需要移动的步数

其实还有一种更简单的方法：

考虑到，如果我定义两个指针：`fast`与`slow`，我**让两个指针同时运动**，两个指针之间相差一定的步数，只要`fast`指向空的时候`slow`正好指向**待删除节点的前一个节点**，那么我们便可以实现节点的删除
注：**删除一个节点只需要一个指针**

>通过画图我们可以得知，只需要让`fast`指针移动`n+1`步就可以让两个指针同时移动了

```cpp

ListNode* removeNthFromEnd(ListNode* head, int n) 
{
    ListNode* dummyhead = new ListNode;
    dummyhead->next = head;
    ListNode* fast = dummyhead, *slow = dummyhead;
    for(int i = 0; i < n + 1; i++)
        fast = fast->next;
    while(fast)
    {
        fast = fast->next;
        slow = slow->next;
    }
    ListNode* tmp = slow->next;
    slow->next = tmp->next;
    delete tmp;
    return dummyhead->next;
}

```

>使用虚拟头节点在返回的时候可以之间返回`dummyhead->next`，这样子更方便

---

对链表（一个与两个链表均同理）用双指针的时候，我们两个指针可以**同时同地移动**，也可以**同时不同地移动**

对于前者，我们可以让**两个指针在链表的开始节点移动**（数组的话可以在尾部开始移动）

对于后者，我们定义两个指针`fast`与`slow`，**我们让`fast`与`slow`相差一定的节点数**（可以是题目给的数也可以是两个链表的长度差），**之后再让两指针同时移动**

当然，我们也可以定义两个指针`slow`与`fast`，我们让**`fast`一次走两个节点**，**`slow`一次走一个节点**，他们一定会相遇，这种通常用在循环链表上。*见力扣142*

## 链表反转

递归实现

```cpp
ListNode* reverseList(ListNode* head) 
{
    if(head == NULL)
        return NULL;
    if(head->next == NULL)
        return head;
    ListNode* tmp = reverseList(head->next);
    head->next->next = head;
    head->next = NULL;
    return tmp;
    
}
```

>为什么要写`head->next->next = head`

tmp**始终**记录的都是头节点，因此只能是用head->next->next来表示**当前节点**（该节点可以移动），而`head`则表示**当前节点的前一个节点**

>为什么判断`head->next == NULL`之后是返回`head`

我们`tmp`的最终值只能是最后一个节点，由于`tmp = reverseList(head->next)`，因此在`head->next`为空指针的时候我就要返回`head`


双指针实现

```cpp
ListNode* reverseList(ListNode* head) 
{
    if(head == NULL)
        return NULL;
    ListNode* pre = NULL, *cur = head;//cur为当前处理的节点，pre为该节点的前一个节点
    while(cur)//我对某个节点处理，只能是对这个节点进行判断
    {
        ListNode* tmp = cur->next;
        cur->next = pre;
        pre = cur;
        cur = tmp;
    }
    return pre;
}
```

双指针递归实现
```cpp

ListNode* reverseList(ListNode* head)
{
	return reverse(NULL, head);
}

ListNode* reverse(ListNode* pre, ListNode* cur)
{
	if(cur == NULL)
		return pre;
	ListNode* tmp = cur->next;
	cur->next = pre;
	return reverse(cur, tmp);
}

```

>为什么在判断`cur == NULL`之后返回的是`pre`

由于`pre`总表示`cur`的前一个节点，因此当`cur`为`NULL`时，说明`pre`已经到达最后一个节点，由于需要直接返回最后一个节点，因此我需要返回`pre`



---

# 哈希表

哈希表是一种用于查询的工具，具体来说，我将数据录入哈希表当中，每个数据对应一个索引key值，在我需要判断某个元素是否存在这个哈希表当中时，我直接去找它的索引就行

**也就是说，当我需要快速判断一个元素是否在一个集合当中时，我就可以考虑用哈希表了**

在引入哈希表前，我们需要先介绍四个容器**（这四个容器均不涉及哈希表）**

>`set`
>>插入容器当中的数据会**自动排序（默认从小到大）**，元素不能更改，并且**不允许相同的元素出现**

## 相关操作

	begin()--返回指向第一个元素的迭代器
	
	clear()--清除所有元素
	
	count()--返回某个值元素的个数
	
	empty()--如果集合为空，返回true
	
	end()--返回指向最后一个元素的迭代器
	
	equal_range()--返回集合中与给定值相等的上下限的两个迭代器
	
	erase()--删除集合中的元素
	
	find()--返回一个指向被查找到元素的迭代器
	
	get_allocator()--返回集合的分配器
	
	insert()--在集合中插入元素
	
	lower_bound()--返回指向大于（或等于）某值的第一个元素的迭代器
	
	key_comp()--返回一个用于元素间值比较的函数
	
	max_size()--返回集合能容纳的元素的最大限值
	
	rbegin()--返回指向集合中最后一个元素的反向迭代器
	
	rend()--返回指向集合中第一个元素的反向迭代器
	
	size()--集合中元素的数目
	
	swap()--交换两个集合变量
	
	upper_bound()--返回大于某个值元素的迭代器
	
	value_comp()--返回一个用于比较元素间的值的函数


>`mutilset`跟`set`一样，只不过`mutilset`**允许相同的元素**

---

>`map`容器当中的每一个元素均为一个**对组**，即每个元素成对出现
>
>>`map`容器当中，对组的`first`为索引`key`值，`second`为`value`值
>
>>`map`会**按照`key`值来对元素进行排序**，并且`map`**不允许有相同的`key`值出现**
>
>>`map`只检测`key`值是否相同，它允许有相同的`value`值
>
>>`map`当中的`value`值是可以更改的，`set`当中的不行
>>
>>>相关操作

	begin()         返回指向map头部的迭代器
	
	 clear(）        删除所有元素
	
	 count()         返回指定元素出现的次数
	
	 empty()         如果map为空则返回true
	
	 end()           返回指向map末尾的迭代器
	
	 equal_range()   返回特殊条目的迭代器对
	
	 erase()         删除一个元素(按照key值删除而不是按照value值删除)
	
	 find()          查找一个元素（按照key值查找，返回迭代器）
	
	 get_allocator() 返回map的配置器
	
	 insert()        插入元素
	
	 key_comp()      返回比较元素key的函数
	
	 lower_bound()   返回键值>=给定元素的第一个位置
	
	 max_size()      返回可以容纳的最大元素个数
	
	 rbegin()        返回一个指向map尾部的逆向迭代器
	
	 rend()          返回一个指向map头部的逆向迭代器
	
	 size()          返回map中元素的个数
	
	 swap()           交换两个map
	
	 upper_bound()    返回键值>给定元素的第一个位置
	
	 value_comp()     返回比较元素value的函数


好了，下面我们引入两个容器，其底层实现为哈希表

>`unordered_set`跟`set`一样，不过它的元素是无序的，并且不允许相同元素出现，相关操作跟`set`一样
>
>`unordered_set`**不允许`value`值被修改**
>
>`unordered_map`跟`map`一样，不过不会按照`key`值进行排序
>
>`unordered_map`的查找是根据`key`值进行查找的，而不是根据`value`值进行查找
>
>`unordered_map`支持用中括号来访问`value`值，如果该`key`值对应的`value`值不存在，那么它会自动创建一个`value`值**并赋值为0**，并且`value`值是可以被修改的


在实际解题当中，由于`unordered_set`与`unordered_map`都是哈希表，但前者仅仅只是具备查询功能，后者可以实现**对元素出现次数的记录**，因此，**如果不需要对元素出现次数进行考虑时，我们一般选择前者**

不管是用哈希表还是二分查找，我们都需要**知道一个确定的元素才可以进行查找**

注：`vector`的删除是**按照元素删除**，`map`与`set`是**按照`key`值删除**

---



## 总结

其实数组也是一种简易的哈希表，当我们在处理字符串的时候，如果**都是小写字符**或**都是大写字符**，那么我们就可以用数组来解（对于每个字符，直接减去字符a或A就可以直接得到对应下标），至于为什么不用`map`或者`set`，因为这两个底层都是红黑树，十分耗时（这种的话可以不用`unordered_set`与`unordered_map`）
>对应题目：力扣242、383

如果题目中**没有限制数组的大小**，那么这个时候就不能用数组（虽然`vector`具有自动扩容的功能，**但这个数组本质上我是想把它当成哈希表一样对待**，因此**我需要用到数组的下标以及下标对应的元素**，而一旦涉及到使用数组的下标，我就必须要对这个数组进行初始化，**对于大小不确定的数组，我无法对其初始化**）

除此之外还有一点，数组是连续的空间，一旦哈希值跨度很大（即数组下标跨度很大），就会造成浪费空间

>对应题目：力扣349

`set`与`map`、`mutilset`与`mutilmap`、`unordered_set`与`unordered_map`均可以做哈希表，分`set`与`map`来说（因为`unordered_set`与`unordered_map`均可以看成`set`与`map`的无序版本）

对于`set`而言，它是集合，只有`key`值的概念，并且它的`key`值是有序的。如果我**仅仅需要看一个数是否在数组当中时**，我便可以用`set`
>对应题目：力扣349、202

对于`map`而言，它有`key`值与`value`值的概念，并且它是按`key`值进行排序的。如果涉及到**一个数字出现的次数等需要记录两个数据的情况**，`set`便不再适用

用`map`的话一般是用`key`值表示**数组元素**，用`value`值表示**数组下标**，在这种情况下，如果不要求数组元素有序的话可以选用`unordered_map`（因为`map`与`mutilmap`均会对`key`值进行排序）

# 字符串

字符串跟数组是一样的，`vector<char>`跟`string`并没有区别，只不过`string`类增加了很多对字符的操作

正因为字符串跟数组一样的特性，因此需要删除数组当中**特定元素**的话可以直接用**双指针**

>力扣27
>
>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
>
>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。
>
>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。


下面给出我的思路：

>一个最直接的想法是直接一层循环，当我找到特定元素之后再在里面套一层循环来更新数组（把**后面的数字**往前面移动，不过这**一层循环需要把整个数组遍历一遍**）。当内层循环结束之后，外层指针加一，不断循环这一过程。

可以看到，这里增加时间复杂度的主要原因是**只要数组当中出现了特定值，我就需要把数组的后面部分整个往前移动**。也就是说我们移动的是后面的整个部分，即从**出现特定值**之后就要开始移动了。而两层循环实际上就是两个指针，在没有出现特定值的时候，两个指针同时移动。如果一旦出现特定值，我们让内层指针跳过这个特定值之后不断地对外层指针进行赋值，这样便实现了数组的移动。处于统一操作的需要，我们让两个指针同时移动的时候也直接赋值。

```cpp
	class Solution {
	public:
    int removeElement(vector<int>& nums, int val) 
	{
		int left = 0;
		for (int right = 0; right < nums.size(); right++)
		{
			if (nums[right] != val)
				nums[left++] = nums[right];
		}
		return left;
	}
	};
```

## KMP算法

```cpp
class Solution {
public:
    int strStr(string haystack, string needle)
    {
        if (needle.size() == 0)
            return 0;
        int next[10000] = { 0 };
        GetNext(next, needle);
        int j = 0;
        for (int i = 0; i < haystack.size(); i++)
        {
            while (j > 0 && needle[j] != haystack[i])
                j = next[j - 1];
            if (needle[j] == haystack[i])
                j++;
            if (j == needle.size())
                return i - needle.size() + 1;
        }
        return -1;
    }

    void GetNext(int* next, string& s)
    {
        int j = 0;
        next[0] = j;
        for (int i = 1; i < s.size(); i++)//j表示前缀字符串的末尾，i表示后缀字符串的末尾
        {
            while (j > 0 && s[j] != s[i])
                j = next[j - 1];//j跳到j前面(不包括j)的字符串中最大相同前后缀的值所对应的字符处，相当于减小前缀的长度
                                //为什么是按照next数组的值来进行跳动?
                                //由于next数组里面的值均为该字符之前(包括该字符)的字符串当中最大相同前后缀的值，这样我便可以直接跳过
                                //重复段(前后缀相同)
            if (s[j] == s[i])
                j++;
            next[i] = j;//将前缀长度赋给i, j+1表示前缀长度
        }

    }
};

```

# 栈与队列

## 概述

在进入栈与队列前，我们需要先回答四个问题

1. C++中的stack是容器吗

2. 我们使用的stack是属于哪个版本的`STL`

3. 我们使用的`STL`中的stack是如何实现的

4. stack提供迭代器来遍历stack空间吗


首先我们先介绍三个最普遍的`STL`版本

1. `HP STL` 其他版本的C++ `STL`，一般是以`HP STL`为蓝本实现出来的，`HP STL`是C++ `STL`的第一个实现版本，而且开放源代码。

2. `P.J.Plauger STL `由`P.J.Plauger`参照`HP STL`实现出来的，被Visual C++编译器所采用，不是开源的。

3. `SGI STL` 由Silicon Graphics Computer Systems公司参照`HP STL`实现，被Linux的C++编译器`GCC`所采用，`SGI STL`是开源软件，源码可读性甚高。


我们先讨论栈

栈是先进后出，即它提供`push`和`pop`接口来实现对元素的操作，**所有的元素都必须满足此性质**，因此栈不提供随机访问的功能，也不提供迭代器

其次，**栈是以底层容器完成其所有的工作，对外统一提供接口，底层容器是可以替换的（也就是说我们可以选择使用哪种容器来实现栈的功能）**

基于此，`STL`中的栈往往不被归类为容器，而是`container adapter`（容器适配器）

那么问题是，`STL`中的栈的底层实现是用什么容器

实际上，栈的底层实现可以是`vector`、`deque`、`list`，主要是数组与链表

我们常用的`SGI STL`，如果没有指定底层实现的话默认是用`deque`为底层结构

当然，我们也可以指定其底层实现为`vector`

```cpp
std::stack<int, vector<int> >s;
```

`STL`中的`list`与`stack`一样，默认是用`deque`来实现队列功能，指定其底层实现也跟`stack`一样

## string与vector跟stack的联系

+ `string`跟`vector`一样，都支持`push_back`与`pop_back`的操作

+ `push_back`与`pop_back`分别是尾插和尾删，即我们可以认为`vector`是一个**支持随机访问的栈**，**栈顶元素为最后一个元素**


## 单调队列

我们定义这样一个队列：**队列内的元素一定单调增或单调减**，这样的队列称之为单调队列

单调队列的底层容器我们默认用`deque`容器来实现

值得注意的是，单调队列中不一定`push`就不能删除队列中的元素，`pop`就不能增加队列当中的元素。即`push`和`pop`函数的定义可以是

```cpp
void push(int val);

void pop(int val);
```

`push`表示添加值为`val`的元素，`pop`表示删除值为`val`的容器

由于单调队列的实现各不相同，因此这里我们给出一种具体实现

```cpp
    class humdrumqueue
    {
    public:
        deque<int>deq;
        void pop(int value)
        {
            if (!deq.empty() && deq.front() == value)
                deq.pop_front();
        }

        void push(int value)
        {
            while (!deq.empty() && deq.back() < value)
                deq.pop_back();
            deq.push_back(value);
        }

        int front()
        {
            return deq.front();
        }
    };
```

### 关于vector的补充

`vector`中的`insert`和`emplace`都可以插入元素

* `insert`的插入是先将该元素单独生成，然后再复制到指定位置，即会调用该对象的**构造函数**和**拷贝构造函数**

* `emplace`是直接在指定位置生成该元素，只调用**构造函数**

因此`emplace`的速度快于`insert`

`push_back`同理


# 二叉树

## 递归的写法

二叉树经常会涉及到递归的问题，在这里我们详细总结一下递归的写法

+ **确定递归函数的参数与返回值**。我们需要知道在递归中哪些**参数是需要不断改变的**，那么就将这些参数放到递归函数里面。同理，我们需要明确每次**递归的返回值**是什么进而确定**递归函数的返回值**（递归的返回值与递归函数的返回值并不相同）

+ **确定终止条件**

+ **确定单层递归的逻辑**。这里的单层递归指的是递归函数每次重复使用的部分

## 二叉树的翻转问题

>给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点

这道题我们既可以用递归，也可以用迭代

递归的话只支持**先序和后序**

```cpp
TreeNode* invertTree(TreeNode* root) 
{
    if (root == NULL) return root;
    swap(root->left, root->right);  // 中
    invertTree(root->left);         // 左
    invertTree(root->right);        // 右
    return root;
}
```

迭代的话我们用统一迭代法，**前中后三种都可以**

```cpp
TreeNode* invertTree(TreeNode* root) 
{
    stack<TreeNode*> st;
    if (root != NULL) st.push(root);
    while (!st.empty()) {
        TreeNode* node = st.top();
        if (node != NULL) {
            st.pop();
            if (node->right) st.push(node->right);  // 右
            if (node->left) st.push(node->left);    // 左
            st.push(node);                          // 中
            st.push(NULL);
        } else {
            st.pop();
            node = st.top();
            st.pop();
            swap(node->left, node->right);          // 节点处理逻辑
        }
    }
    return root;
}
```

相应地，我们也可以用层次遍历来实现，原理跟迭代相同

>为什么前中后三种顺序均可以

迭代的是用栈来实现的，那么在不考虑将元素出栈的条件下，我将所有的节点全部压入栈中，然后挨个交换它们的左右孩子。我们发现，这个过程是不涉及**节点之间的先后顺序的**，因此前中后三种顺序都可以


>为什么不能用中序递归

上面递归调用中对应的中序遍历的代码为：

```cpp
TreeNode* invertTree(TreeNode* root) 
{
    if (root == NULL) return root;

    invertTree(root->left);         // 左
    swap(root->left, root->right);  // 中
    invertTree(root->right);        // 右
    return root;
}
```

不难发现，我会先遍历某个节点的**左指针**，此时**左指针指向左孩子**。

然后我会交换了该节点的左右孩子，此时 **原先的左指针指向的是右孩子，原先的右指针指向的是左孩子**。

接着，我再去遍历该节点**右指针**，我们会发现此时的**右指针指向的是左孩子**，这里就会导致该节点**右孩子遍历不到的问题**

实际上，我们的代码应该这么写：

```cpp
TreeNode* invertTree(TreeNode* root) 
{
    if (root == NULL) return root;

    invertTree(root->left);         // 左
    swap(root->left, root->right);  // 中
    invertTree(root->left);         // 左
    return root;
}
```

这里要说明一点，我们通常说的遍历左孩子、右孩子只是简单的表述，实际上应该是**通过左指针去遍历左孩子**，**通过右指针去遍历右孩子**

## 二叉树最大、最小深度问题

关于这个问题，用层次遍历可以很容易得出结果

最大深度就遍历完所有层，最小深度就是当遍历到叶子节点的时候之间返回

我们重点分析递归

先讨论最大深度的问题

按照上面的递归三部曲，我们需要确定的是单层递归的逻辑

对于一个节点而言，我们的做法是**先得到其左右子树的高度**，再加一，最后再返回

这里**先得到其左右子树的高度**，实际上就是指我们要用到**后序遍历**

想到这里代码也就不难写了

```cpp
int maxDepth(TreeNode* root)
{
    if (root == NULL) return 0;
    int right = maxDepth(root->right);
    int left = maxDepth(root->left);
    return right > left ? right + 1 : left + 1;
}
```

我们可以简单一点，两行解决

```cpp
int maxdepth(treenode* root) {
    if (root == null) return 0;
    return 1 + max(maxdepth(root->left), maxdepth(root->right));
}
```

对于最小深度，实际上我们递归的逻辑是不变的，也是后序遍历，只不过在返回的时候会有改变

```cpp
int minDepth(TreeNode* root)
{
    if (root == NULL) return 0;
    int left = minDepth(root->left);
    int right = minDepth(root->right);
    if (root->left == NULL && root->right != NULL)//左边为空，递归向右拐
        return right + 1;
    if (root->left != NULL && root->right == NULL)//右边为空，递归向左拐
        return left + 1;
    return 1 + min(left, right);
}
```

对于一个节点，如果我已知它的左右子树的高度，我需要取的是**二者的较小值**，但这里有个问题是如果一个节点有某一个子树为空，就会导致该节点向上返回的时候必定返回0，因此我们在这种情况下要让递归转弯

## 关于二叉树的递归与回溯问题

在二叉树递归的时候，**如果我是需要遍历整一颗树，那么我的递归函数就不能有返回值**，**如果仅仅是遍历某一条线路，则我的递归函数就一定有返回值**

二叉树的递归往往隐藏着回溯（如果代码简短的话）。事实上，有递归的地方就一定会有回溯，只是看这个回溯要如何理解

对于有返回值的函数，**其回溯往往指的是该函数的返回值**。（这种情况下我们通常是用**后序遍历**这个二叉树）这个时候我已经得到**在该节点上我所需要得到的信息**，之后我再对这些信息进行操作

对于没有返回值的函数，**其回溯会体现在该函数的参数部分**。这时的回溯我们可以理解为：我先递归往下走，**最后我一定会回到我目前这个位置**，即我最终还是对这个位置所能获取的信息进行处理。


>给定一个二叉树的 根节点 root，请找出该二叉树的**最底层最左边**节点的值

我们先用递归来解决这个问题。首先我们需要找到**最底层最左边**的节点，既然是最底层，那么我们可以通过比较深度来实现

只要当前深度比目前已记录的最大深度大，我们就赋值（对深度和可能满足题目条件的节点）

```cpp
class Solution 
{
public:
    int Maxdep = INT32_MIN;
    int val = 0;
    
    void Travel(TreeNode* root, int depth)
    {
        if (root == NULL)
            return;
        if (depth > Maxdep)
        {
            Maxdep = depth;
            val = root->val;
        }
        if (root->left)
            Travel(root->left, depth + 1);//回溯隐藏在这里
        if (root->right)
            Travel(root->right, depth + 1);
    }

    int findBottomLeftValue(TreeNode* root) 
    {
        Travel(root, 0);
        return val;
    }
};
```

上面这个代码实际上是**先序遍历**

>这个代码能够保证一定得到的就是最左边的节点的值吗

我最后的返回值是`val`，我是先对该节点的左子树进行遍历并且我只在高度更新的时候才对`val`赋值。如果最底层有多个叶子，由于高度没变，因此也不会赋值给`val`



---



* 当我需要遍历二叉树的一个路径的时候，我们递归函数的返回值可以用`bool`类型。我们将该函数放在**if的判断部分**，对于它的终止条件，我们**只有在条件成立的情况下才返回`true`，否则都返回`false`**

通常函数递归的逻辑如下

```cpp
if(递归函数(root->left))
    return;
if(递归函数(root->right))
    return;
```

函数返回为

```cpp
if(条件成立)
    return true
//内容
    
//最后
    return false;
```

* 当我们递归整颗二叉树时，我们用回溯的写法如下

```cpp
返回值类型 left = 递归函数(root->left);
返回值类型 right = 递归函数(root->right);
//下面对left与right进行逻辑处理
```



注：

* 回溯相当于是将这棵树**自下而上**开始遍历，这对应**后序遍历**
* 如果要**自上而下**开始遍历这棵树，则用到**先序遍历**





## 递归函数返回值问题

关于这个问题，我们总结以下几点：

* 我需要**遍历整棵树**并且我**不需要**对递归的结果进行处理，那么我不用写返回值

参考[513. 找树左下角的值 - 力扣（LeetCode）](https://leetcode.cn/problems/find-bottom-left-tree-value/)

* 我需要**遍历整棵树**并且我**需要**对递归的结果进行处理，那么我需要写返回值

参考[222. 完全二叉树的节点个数 - 力扣（LeetCode）](https://leetcode.cn/problems/count-complete-tree-nodes/)

由于代码简写，实际上是将返回值作为结果返回

* 如果递归仅涉及一条路线，那么**必须要有返回值**并且条件合适要**及时**返回

参考[112. 路径总和 - 力扣（LeetCode）](https://leetcode.cn/problems/path-sum/)



这里我们以第三点为例进行说明，我们主要看回溯                                                                      

>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。
>
>叶子节点 是指没有子节点的节点。

### 递归写法

```c++
class Solution 
{
public:
    bool Traversal(TreeNode* root, int ant)//这里我们将ant的初始值设为targetsum，不从0开始是因为那样太麻烦
    {
        if (root->left == NULL && root->right == NULL && ant == 0)
            return true;
        if (root->left == NULL && root->right == NULL)
            return false;
        if (root->left)
            if (Traversal(root->left, ant - root->left->val))//回溯体现在这里
                return true;
        //实际上这里我们的代码是简写了，实际上应该是
        /*
        if(root->left)
        {
        	ant -= root->left->val;
        	if(Traversal(root->left, ant))
        		return true;
        	ant += root->left->val;
        }
        先加后减，这才是真正的回溯
        */
        if (root->right)
            if (Traversal(root->right, ant - root->right->val))//上面的ant没有变化使得这里的ant也不会发生改变
                return true;
        return false;
    }

    bool hasPathSum(TreeNode* root, int targetSum)
    {
        if (root == NULL) return false;
        return Traversal(root, targetSum - root->val);
    }
};
```

我们着重分析当**递归函数为`bool`类型的时候的情况**。当递归函数为`bool`类型时，我们不能像`void`那样直接调用，而是应当将其放在`if`的条件判断内，至于`if`的返回值，则根据情况进行判断

### 迭代写法

首先这里不能用层次遍历，只能用`stack`来模拟递归

再者，与递归类似，我们需要一个值来记录每个节点对应的数值（从根节点到该节点的数值总和）

这里有一个问题是该数值必须要与节点对应

因此我们可以使用对组来解决这个问题

```cpp
    bool hasPathSum(TreeNode* root, int targetSum)
    {
        if (root == NULL) return false;
        stack<pair<TreeNode*, int> >st;//用对组来存储，前者为节点指针，后者为从根节点到该节点的路径总和
        st.push(pair<TreeNode*, int>(root, root->val));
        while (!st.empty())
        {
            pair<TreeNode*, int> cur = st.top();
            st.pop();
            if (cur.first->left == NULL && cur.first->right == NULL && cur.second == targetSum)
                //是否为叶子节点是前置条件
                return true;
            if (cur.first->left != NULL)
                st.push(pair<TreeNode*, int>(cur.first->left, cur.second + cur.first->left->val));
            if (cur.first->right != NULL)
                st.push(pair<TreeNode*, int>(cur.first->right, cur.second + cur.first->right->val));
        }
        return false;
    }
```



## 二叉排序树的分析

关于二叉排序树，其中序遍历后得到的数组一定是**有序的**

因此如果需要判断一个二叉树是不是二叉排序树，我们只能通过**中序遍历**来解决这个问题



### 求任意两节点的最小差值

[530. 二叉搜索树的最小绝对差 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/)

>给你一个二叉搜索树的根节点 `root` ，返回 **树中任意两不同节点值之间的最小差值** 。
>
>差值是一个正数，其数值等于两值之差的绝对



#### 递归写法

递归的话我们不简要说明：先**中序**遍历得到数组后我们再判断该数组是否是有序的。*该数组的元素一定是递增的，并且我们只需要比较相邻的两个元素即可*

这里需要说明的是，由于题目让我们返回**任意两个不同节点的最小差值**。如果是比较一个节点的两个孩子的话，其差值必定>=2，如果比较的是该节点与它的其中一个孩子，那么差值必定>=1，因此我们只需要比较数组中的相邻两个值即可

我们着重讨论迭代的情况

迭代的话可用的数据结构有stack和queue，stack是用于**模拟递归的**，queue是用于**层序遍历的**

因此如果我们需要模拟递归，则用stack，如果需要层序遍历这颗二叉树，则用queue

这里我们应当是模拟递归，选用stack，并且只能用中序遍历

由于需要比较的节点有两个(当前节点cur和前一个结点pre)，因此我们需要两个指针

只要当前节点不为NULL，这就说明我们需要将**该节点的左孩子压入stack中**，该操作会一直进行直到cur为NULL(这里是**左**的操作)

如果当前节点为NULL，说明已经到达**最左端**，此时我们需要取出栈顶结点，将其赋值给cur(这里是**中**的操作)

然后我们再将cur与pre的差值与目前已记录的最小值进行比较，此时我们还需要一个变量来记录**目前的最小值**

最后我们更新cur和pre(先pre后cur)

```cpp
int getMinimumDifference(TreeNode* root)
{
    stack<TreeNode*>st;
    TreeNode* cur = root;//前一个节点
    TreeNode* pre = NULL;//当前处理节点
    int ret = INT32_MAX;
    while (!st.empty() || cur != NULL)
    {
        if (cur != NULL)
        {
            st.push(cur);
            cur = cur->left;//左
        }
        else
        {
            cur = st.top();//取栈顶元素，中
            st.pop();
            if (pre != NULL)
                ret = min(ret, cur->val - pre->val);
            pre = cur;
            cur = cur->right;//右
        }
    }
    return ret;
}
```



### 求二叉树中的众数

[501. 二叉搜索树中的众数 - 力扣（LeetCode）](https://leetcode.cn/problems/find-mode-in-binary-search-tree/)

> 给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。
>
> 如果树中有不止一个众数，可以按 任意顺序 返回。
>
> 假定 BST 满足如下定义：
>
> * 结点左子树中所含节点的值 小于等于 当前节点的值
> * 结点右子树中所含节点的值 大于等于 当前节点的值
> * 左子树和右子树都是二叉搜索树



#### 递归写法

我们首先讨论如何求一个数组当中的众数(不止一个众数)

我们可以先遍历一次数组，找出这个数组当中一个数出现的maxCount(最大频率)。然后我们再遍历一遍这个数组，将**出现频率等于maxCount的数放入结果数组中

上面这种方法遍历了两遍数组，当然我们也可以遍历一遍

我们定义两个变量：当前这个数的频率(count)，目前的最大频率(maxCount)。只要当前这个count等于maxCount，我们就将这个数加入到结果数组中

那么这样就会有一个问题，我目前的maxCount不是**真正的最大频率**怎么办

在这种情况下，我们需要更新maxCount并且将结果数组**清空**(这是因为之前的数全部不符合条件)

具体写法如下：

```cpp
if (count == maxCount) // 如果和最大值相同，放进result中
{
    result.push_back(cur->val);
}
if (count > maxCount) // 如果计数大于最大值
{
    maxCount = count;   // 更新最大频率
    result.clear();     // 很关键的一步，不要忘记清空result，之前result里的元素都失效了
    result.push_back(cur->val);
}
```

完整代码

```cpp
class Solution 
{
public:
    int count = 0;//记录目前这个数出现的次数
    int Maxcount = 0;//记录目前最大的频率
    TreeNode* pre = NULL;//记录前一个节点

    void Traversal(TreeNode* root, vector<int>& ret)
    {
        if (root == NULL)
            return;
        if (root->left)
            Traversal(root->left, ret);
        if (pre == NULL)//此时已到达最左端的节点
            count = 1;
        else if (root->val == pre->val)//与前一个节点相同
            count++;
        else//与前一个节点不同，将当前节点的频率设为1
            count = 1;

        pre = root;//更新pre

        if (count == Maxcount)//目前的count已到达已记录的Maxcount
            ret.push_back(root->val);
        if (count > Maxcount)
        {
            ret.clear();//直接重置
            Maxcount = count;//更新Maxcount
            ret.push_back(root->val);
        }
        Traversal(root->right, ret);
    }

    vector<int> findMode(TreeNode* root)
    {
        vector<int>ret;
        Traversal(root, ret);
        return ret;
    }
};
```



### 插入一个节点

[701. 二叉搜索树中的插入操作 - 力扣（LeetCode）](https://leetcode.cn/problems/insert-into-a-binary-search-tree/)

> 给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。
>
> 注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。



#### 递归写法

对于二叉搜索树的**插入与删除**操作，我们都可以用**先序遍历**来实现

我们在遍历的时候只要`root->val > key`，那么我们就**向右走**，只要`root->val < key`，我们就**向左走**

那么这里有一个问题是，我们该如何具体实现向右走和向左走的代码呢

由于我们用的是递归来实现，那么递归就一定会有返回值。**当这一层的逻辑处理完之后将此节点返回上去**，在调用递归函数的那一层我们可以用该节点的**左孩子或右孩子接住其返回值**，这样便实现了向左向右走

具体代码如下

```cpp
TreeNode* insertIntoBST(TreeNode* root, int val)
{
    if (root == NULL)
    {
        TreeNode* cur = new TreeNode(val);
        return cur;
    }
    if (root->val > val)
        root->left = insertIntoBST(root->left, val);
    if (root->val < val)
        root->right = insertIntoBST(root->right, val);
    return root;
}
```



#### 迭代写法

当然，我们也可以用迭代来实现，这就是对指针进行具体的赋值，很简单，直接上代码

```cpp
TreeNode* insertIntoBST(TreeNode* root, int val)
{
    if (root == NULL)
    {
        TreeNode* cur = new TreeNode(val);
        return cur;
    }
    TreeNode* pre = NULL;
    TreeNode* cur = root;
    while (cur != NULL)
    {
        pre = cur;
        if (cur->val < val)
            cur = cur->right;
        else cur = cur->left;
    }
    TreeNode* node = new TreeNode(val);
    if (pre->val < val)
        pre->right = node;
    else pre->left = node;
    return root;
}
```



### 删除一个节点

[450. 删除二叉搜索树中的节点 - 力扣（LeetCode）](https://leetcode.cn/problems/delete-node-in-a-bst/)

> 给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。
>
> 一般来说，删除节点可分为两个步骤：
>
> 1. 首先找到需要删除的节点；
> 2. 如果找到了，删除它。



#### 递归写法

删除一个节点我们会有五种情况

* 此节点为`NULL`的情况

  1. 直接返回`NULL`

* 此节点`非NULL`的情况

  2. 左右孩子均为`NULL`。直接删除该节点并返回`NULL`

  3. 左孩子不为`NULL`，右孩子为`NULL`。删除该节点，返回左孩子

  4. 左孩子为`NULL`，右孩子不为`NULL`。删除该节点，返回右孩子

  5. 左右孩子均不为`NULL`。我们找到右子树中最靠左边的节点，将整个左子树挂在该节点的左孩子上

我们着重分析第五种情况

由于二叉搜索树的特性，一个节点的**左孩子的所有值一定小于该节点**，**右节点的所有值一定大于该节点**

**对于任意一个节点，均有此性质**，那么我们便可以导出如下结论：

* 对于一颗子树，它的**最小值一定在最左边的节点**，**最大值一定在最右边的节点**

* 对于一个节点的左右子树而言，**左子树的所有值一定小于该节点的值**，**右子树的所有值一定大于该节点的值**

基于这两点，如果我们想删除一个节点的话（该节点的左右孩子均存在），我们可以将**该节点的左子树接到该节点右子树中最靠左边的节点的左孩子上**

这里有一点要注意的是：最靠左，说明不能够向右走

具体代码如下

```cpp
TreeNode* deleteNode(TreeNode* root, int key)
{
    if (root == NULL)//Preorder Traversal
        return NULL;
    if (root->val == key)
    {
        if (root->left == NULL && root->right == NULL)
        {
            delete root;
            return NULL;
        }
        else if (root->left == NULL && root->right != NULL)
        {
            TreeNode* cur = root->right;
            delete root;
            return cur;
        }
        else if (root->left != NULL && root->right == NULL)
        {
            TreeNode* cur = root->left;
            delete root;
            return cur;
        }
        else
        {
            TreeNode* cur = root->right;
            while (cur->left)
                cur = cur->left;
            cur->left = root->left;
            TreeNode* node = root->right;
            delete root;
            return node;
        }
    }
    if (root->val < key)
        root->right = deleteNode(root->right, key);
    if (root->val > key)
        root->left = deleteNode(root->left, key);
    return root;
}
```



#### 普通二叉树的删除

对于一个待删除的节点，我们首先先将该节点与**其右子树中最靠左边的节点交换数组**（第一次操作）

然后，我们第二次递归到该节点的时候删除该节点，如果此时该节点的右孩子不为空，则**重复这两步**

```cpp
TreeNode* deleteNode(TreeNode* root, int key) {
    if (root == nullptr) return root;
    if (root->val == key) {
        if (root->right == nullptr) { // 这里第二次操作目标值：最终删除的作用
            return root->left;
        }
        TreeNode *cur = root->right;
        while (cur->left) {
            cur = cur->left;
        }
        swap(root->val, cur->val); // 这里第一次操作目标值：交换目标值其右子树最左面节点。
    }
    root->left = deleteNode(root->left, key);
    root->right = deleteNode(root->right, key);
    return root;
}
```



# 回溯

回溯实际上是一种暴力搜索的方法，对于回溯的理解，我们可以将其类比成一个 n 叉树。树的深度表示递归的层数，树的宽度（叶子节点）表示所有可能出现的结果。

明白这一点后，简单的回溯代码也就会写了。那么我们更进一步，在回溯的基础上考虑**去重**

首先对于这颗 n 叉树而言（ *各个数已经排好序* ），**一条树枝表示一个结果**，**同一层的各个节点表示上一次或者下一次所选择的数**。那么我们的剪枝就有两种情况：对于第一种就是结果集合**不能重复**，对于第二种就是**在这一层上不能两次都选择相同的数**

具体看下面这道题



[40. 组合总和 II - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum-ii/)

> 给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
>
> candidates 中的每个数字在每个组合中只能使用 一次 。
>
> 注意：解集不能包含重复的组合。



这道题里面，结果集合当中可以有重复的数字，但不允许存在两个相同的解集，**即在同一层上不允许选择同一个数**

那么我们该如何去重呢？一个很自然的想法就是只要 `candidates[i-1] == candidates[i]` 我们便 continue 。

但如果我们这么做的话就会导致在**解集当中也不允许出现相同的数字了**，因为当我递归到下一层的时候，初始的位置相对于这一层而言就是`[i+1]` ，这会导致下一层会直接跳过这个数字

那么这个地方，其实我们可以用一个 bool 类型的数组来表示每个数字是否被使用过。

初始时， used 数组的值都是 false ，在我进入递归的时候将其设置为 true ，那么在下一层的递归函数看来就表示`[i-1]`已经使用过了，此时`used[i-1]`为 true。递归会一直向下执行，知道这个数所对应的全部结果都搜寻完毕。

之后就会走到回溯代码，也就是说此时`used[i-1]`又会变为 false ，**这里表示在这一层而言，上一个数字已经被选过了**。而对于已经排好序的数组而言，上一个数字跟这个数字相同的情况下自然就可以跳过当前这个数

具体代码如下

```cpp
class Solution {
public:
    vector<int>path;
    vector<vector<int>>ret;

    void backtracking(vector<int>& candidates, int target, int start, int sum, vector<bool>& used)
    {
        if (sum == target)
        {
            ret.push_back(path);
            return;
        }
        for (int i = start; i < candidates.size() && sum + candidates[i] <= target; i++)
        {
            if (i > 0 && candidates[i] == candidates[i - 1] && !used[i - 1])
            {
                continue;
            }
            path.push_back(candidates[i]);
            sum += candidates[i];
            used[i] = true;
            backtracking(candidates, target, i + 1, sum, used);
            used[i] = false;
            sum -= candidates[i];
            path.pop_back();
        }
        return;
    }

    vector<vector<int>> combinationSum2(vector<int>& candidates, int target)
    {
        sort(candidates.begin(), candidates.end());
        vector<bool>used(candidates.size(), false);
        backtracking(candidates, target, 0, 0, used);
        return ret;
    }
};
```



需要特殊说明的是

* `used[i-1] == true` 表示在一个解集内去重，**这能保证一个解集内不会出现两个一样的数字**
* `used[i-1] == false`表示在同一层去重，**这能保证不会出现两个一样的解集**



[78. 子集 - 力扣（LeetCode）](https://leetcode.cn/problems/subsets/)

> 给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。
>
> 解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。



写回溯算法的收集部分时，要看清楚是**收集叶子**还是收集**各个节点**

如果是收集叶子，那么我们需要加上判断条件，此条件即为我们的**收集条件**

如果是收集树的各个节点，那什么都不需要写，直接往里面压就行

具体代码如下

```cpp
class Solution {
public:
    vector<int>path;
    vector<vector<int>>ret;

    void backtracking(vector<int>& nums, int start)
    {
        ret.push_back(path);//什么都不用管，直接往里面放，这就是收集树的各个节点
        for (int i = start; i < nums.size(); i++)
        {
            path.push_back(nums[i]);
            backtracking(nums, i + 1);
            path.pop_back();
        }
        return;
    }

    vector<vector<int>> subsets(vector<int>& nums)
    {
        backtracking(nums, 0);
        return ret;
    }
};
```



## 树层去重和树枝去重

在讨论这个问题之前，我们需要明确一点：在收集阶段，无论我是收集节点还是收集树叶，**这两个动作都与去重无关**

实际上，**收集动作发生在 for 循环之前**，收集节点还是收集树叶的区别仅仅在于是否有 if 判断。而**去重的动作则发生在 for 循环之内**

（当然，我们假定数组已经排序完毕）实际上，树枝去重是保证**结果集合当中的数字不能有重复**，而树层去重则是保证**不会出现两个一模一样的结果集合**。

